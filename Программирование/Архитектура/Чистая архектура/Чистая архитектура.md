![[Pasted image 20240426225345.png]]

###### **Существует также второй вариант, той же архитектуры** , где Фреймворки и драйверы вынесены в отдельный Infrastructure layer

[![In clean architecture, how does one communicate from Infrastructure to  Presentation? : r/dotnet](https://preview.redd.it/in-clean-architecture-how-does-one-communicate-from-v0-9s5cv6bxj9ac1.png?width=700&format=png&auto=webp&s=3a8714a62f35ead3b722b603fac714ef4058dd08)


Clean Architecture объединила в себе идеи нескольких других архитектурных подходов, которые сходятся в том, что **архитектура должна**: 

- быть тестируемой;
- не зависеть от UI;
- не зависеть от БД, внешних фреймворков и библиотек.   

Это достигается разделением на слои и следованием [[Dependency Rule]] (правилу зависимостей).


За последние несколько лет мы видели целый ряд идей относительно архитектуры систем. Каждая из них на выходе давала:  
  

1. **Независимость от фреймворка**. Архитектура не зависит от существования какой-либо библиотеки. Это позволяет использовать фреймворк в качестве инструмента, вместо того, чтобы втискивать свою систему в рамки его ограничений.
2. **Тестируемость**. Бизнес-правила могут быть протестированы без пользовательского интерфейса, базы данных, веб-сервера или любого другого внешнего компонента.
3. **Независимоcть от UI**. Пользовательский интерфейс можно легко изменить, не изменяя остальную систему. Например, веб-интерфейс может быть заменен на консольный, без изменения бизнес-правил.
4. **Независимоcть от базы данных**. Вы можете поменять Oracle или SQL Server на MongoDB, BigTable, CouchDB или что-то еще. Ваши бизнес-правила не связаны с базой данных.
5. **Независимость от какого-либо внешнего сервиса**. По факту ваши бизнес правила просто ничего не знают о внешнем мире.


Вся архитектура представляет независимые модули которые делятся на: 
1 - [[Domain (Entity)|Domain (Entity)]]
2 - [[Application]]
3 - [[API]]
4 - [[Infrastructure]]

## Как данные пересекает границы.
  
Обычно данные, которые пересекают границы — это просто структуры данных. Вы можете использовать базовые структуры или, если хотите, Data Transfer Objects (DTO — один из шаблонов проектирования, используется для передачи данных между подсистемами приложения). Или данные могут быть просто аргументами вызова функций. Или вы можете упаковать его в хэш-таблицу или в объект. Важно, чтобы передаваемые структуры данных были изолированными при передаче через границы. Мы не хотим жульничать и передавать _Сущность_ или строки БД. Мы не хотим, чтобы структуры данных имели какие-либо зависимости, нарушающие _Правило Зависимостей_.  
  
Например, многие фреймворки (ORM) в ответ на запрос к БД возвращают данные в удобном формате. Мы могли бы назвать это RowStructure. Мы не хотим передавать эту структуру через границу. Это было бы нарушением _Правила Зависимостей_ поскольку в этом случае внутренний круг получает информацию о внешнем круге.  
  
Поэтому передача данных через границу всегда должна быть в формате удобном для внутреннего круга.


