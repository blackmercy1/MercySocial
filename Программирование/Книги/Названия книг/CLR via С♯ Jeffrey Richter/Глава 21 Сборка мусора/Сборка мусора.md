Любая программа использует ресурсы — файлы, буферы в памяти, пространство экрана, сетевые подключения, базы данных и т. п. В объектно-ориентированной среде каждый тип идентифицирует некий доступный этой программе ресурс. Чтобы им воспользоваться, должна быть выделена память для представления этого типа. Для доступа к ресурсу вам нужно:

<span style="color:#00b0f0">1. Выделить память для типа, представляющего ресурс (обычно это делается при помощи оператора new в C#).</span>
    
<span style="color:#00b0f0">2. Инициализироватьвыделеннуюпамять,установивначальноесостояниересурса и сделав его пригодным к использованию. За установку начального состояния типа отвечает его конструктор.</span>

<span style="color:#00b0f0">    
3. Использовать ресурс, обращаясь к членам его типа (при необходимости опера- ция может повторяться).</span>
    
<span style="color:#00b0f0">4. В рамках процедуры очистки уничтожить состояние ресурса.</span>

<span style="color:#00b0f0">5. Освободить память. За этот этап отвечает исключительно уборщик мусора.</span>

Если писать код безопасный по отношению к типам, повреждение памяти в ваших приложениях невозможно. Утечки памяти остаются теоретически возможными, но они не происходят в стандартной ситуации. Как правило, утечки памяти возникают из-за того, что приложение хранит объекты в коллекции, но не удаляет их, когда они становятся ненужными.

При использовании экземпляров типов, требующих специальной очистки, модель программирования остается такой же простой. Впрочем, иногда очистка ресурса должна выполняться как можно раньше, не дожидаясь вмешательства уборщика мусора. В таких классах можно вызвать дополнительный метод (называемый Dispose)

При инициализации процесса CLR резервирует область адресного пространства под управляемую кучу, а также указатель, который я называю NextObjPtr. Он определяет, где в куче будет выделена память для следующего объекта, и изначально указывает на базовый адрес этой зарезервированной области адресного пространства.
#### При выполнении оператора C# new среда CLR:  

<span style="color:#00b0f0">1) Подсчитывает количество байтов, необходимых для размещения полей типа (и всех полей, унаследованных от базового типа);</span>

<span style="color:#00b0f0">2) Прибавляет к полученному значению количество байтов ,необходимых для размещения системных полей объекта. У каждого объекта есть пара таких полей:
указатель на объект-тип и индекс блока синхронизации. В 32-разрядных при- ложениях для каждого из этих полей требуется 32 бита, что увеличивает размер каждого объекта на 8 байт, а в 64-разрядных приложениях каждое поле занимает 64 бита, добавляя к каждому объекту 16 байт;</span>

<span style="color:#00b0f0">3) проверяет, хватает ли в зарезервированной области байтов на выделение памяти для объекта (при необходимости передает память). Если в управляемой куче достаточно места для объекта, ему выделяется память, начиная с адреса, на который ссылается указатель NextObjPtr, а занимаемые им байты обнуляются. Затем вызывается конструктор типа (передающий NextObjPtr в качестве параметра this), и оператор new возвращает ссылку на объект. Перед возвратом этого адреса NextObjPtr переходит на первый адрес после объекта, указывая на адрес, по которому в куче будет помещен следующий объект.</span> 

![[Screenshot 2024-05-07 at 09.56.15.png]]


Для управляемой кучи выделение памяти для объекта сводится к простому увеличению указателя — эта операция выполняется почти мгновенно. Во многих приложениях объекты, выделяемые примерно в одно время, тесно связаны друг с другом, к тому же часто к ним обращаются примерно в одно время. Так, обычно сразу после объекта FileStream создается объект BinaryWriter. Затем приложение обращается к объекту BinaryWriter, внутренний код которого использует FileStream. В среде, поддерживающей уборку мусора, новые объекты располагаются в памяти непрерывно, что повышает производительность за счет близкого расположения ссылок. В частности, это значит, что рабочий набор процесса будет меньше, чем у подобного приложения, работающего в неуправляемой среде. Также, скорее всего, все объекты, используемые в программе, уместятся в кэше процессора. Приложение сможет получать доступ к этим объектам с феноменальной скоростью, так как процессор будет выполнять большинство своих операций без кэш-промахов, замедляющих доступ к оперативной памяти.

[[Алгоритм сборки мусора]]

[[Поколения]]

[[Алгоритм на практике]]

[[Запуск уборки мусора]]

[[Большие объекты LOH]]

[[Режимы уборки мусора]]

[[Освобождение мусора при помощи уборки мусора]]