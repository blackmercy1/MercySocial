###### Исходная иерархия и производные типы

Для начала опишем иерархию типов, которой будем оперировать. Вверху иерархии у нас находится `Device`, потомками которого являются `Mouse`, `Keyboard`. У `Mouse` в свою очередь тоже есть потомки — `WiredMouse`, `WirelessMouse`. 


![[Pasted image 20240514102745.png]]

Все любят контейнеры. На их примере наиболее просто объяснить, что подразумевается под производными типами. Если говорить о списках как производных типах, то для типа `Device`производным будет  
`List<Device>` (список устройств). Аналогично, для типа `Keyboard` производным будет `List<Keyboard>` (список клавиатур). Думаю, если и были сомнения, то теперь их нет.

<span style="color:#7030a0">Классическая ковариантность</span>

Ковариантность также легче изучать на примере контейнеров. Для этого выделим часть иерархии (ветвь) — `Keyboard : Device` (клавиатура является устройством, клавиатура частный случай устройства). Опять возьмём списки и построим ковариантную производную ветвь — `List<Keyboard> : List<Device>` (список клавиатур является частным случаем списка устройств). Как видим, наследование передалось в прямом порядке.

```cs
void DoSmthWithDevices(List<Device> devices) { /* действия с элементами списка */ }...List<Keyboard> keyboards = new List<Keyboard> { /* заполнение списка */ };DoSmthWithDevices(keyboards);
```

<span style="color:#7030a0">Классическая контравариантность</span>

Каноническим для изучения контравариантности является рассмотрение её на основе делегатов. Допустим, у нас есть обобщённый делегат:

```csharp
public delegate void Action<T> Super(T something);
```

Для исходного типа `Device` производным будет `Action<Device>`, а для `Keyboard` — `Action<Keyboard>`. Полученные делегаты могут представлять функции, которые выполняют какие-то действия над устройством или мышью соответственно. Для ветви `Keyboard : Device` построим производную контравариантную ветвь — `Action<Device> : Action<Keyboard>` (действие над устройством является частным случаем действия над клавиатурой — звучит странно, но так и есть). Если можно нажать клавишу на клавиатуре, то это не значит, что и на устройстве можно нажать её (оно может не иметь понятия о том, что такое клавиша). Но если можно подключить устройство, то можно этим же способом (методом, функцией) подключить и клавиатуру. Как видим, наследование передалось в обратном порядке.

![[Pasted image 20240514104231.png]]

```csharp
void DoSmthWithKeyboard(Action<Keyboard> actionWithKeyboard) 
{ 
/* выполнение actionWithKeyboard над клавиатурой */ 
}

Action<Device> actionWithDevice = device => device.PlugIn();

DoSmthWithKeyboard(actionWithDevice);
```

