---
tags:
  - Programming
  - Book
  - CLR
  - CSharp
  - DotNet
  - Performance
Author: Jeffrey Richter & @TheJustLink
Date: 2013-01-01
StartDate: 2024-04-09
EndDate: ""
---
## Резюме

Книга про устройство [[CLR]], о том как работают многие конструкции языка [[CSharp]] под капотом.
Не подходит для новичков.
Вторую и третью главу пропускаем (про сборки и развёртывание, useless).

Мне пришлось переосмыслить эту книгу, обновить данные из актуальных исходников и анализировать поведение современного компилятора (с помощью sharplab).

Чтобы легко понять как работает C#/CLR на самом деле, мы начнём с самых простых и фундаментальных его частей, это даст понять причину использования многих вещей в компиляторе. Никто ведь вам не говорил про истинный смысл упаковки/распаковки? Или почему ссылочные/значимые типы - это сказка для упрощения понимания, а также причина многих мифов и легенд о работе C#/CLR? Или почему приведение типов - это ложь?

## Сырые данные

*Речь не про структуры в C#*

Сырые данные (RawData/ValueObject) - это просто данные, байты, которые выравниваются исходя из многих факторов (CLR, платформа, атрибуты, порядок и смещения заданные разработчиком).
Кроме данных здесь ничего нет, даже метаданных, вся магия происходит во время компиляции.

Сырые данные могут находиться хоть на стэке, хоть в куче. На сырые данные можно получить ссылку, а можно копировать целиком.
Ссылаться стоит на данные больше ~двух указателей (16байт на x64) в размере, в остальном случае быстрее копировать и получать доступ напрямую.

Их преимущества: простота, лёгкость, скорость работы с ними и богатые возможности для оптимизации (со стороны JIT компилятора и программиста), отсутствие дорогостоящих аллокаций и сборки мусора.

Их недостатки: отсутствие метаданных, следовательно, отсутствие полиморфизма подтипов (sub-type, механизма наследования в C#), а также отсутствие работы с типом (схемой) из-за отсутствия тех же метаданных.
Т.е мы не можем узнать исходный тип (схему) сырых данных в runtim-е, следовательно, и поменять его не можем.
Однако во время компиляции мы знаем тип (схему), методы и манипуляции с полями вставляются во время компиляции и применяются к сырым данным.

Также сырые данные должны быть полностью инициализированы для использования. Т.е их не может не быть, они должны быть инициализированы хоть нулями, но данные должны быть представлены, т.к они занимают фиксированное место в памяти.

Многие эти моменты делают те же классы/структуры/enum-ы теми, кто они есть. Позже мы увидим как типы (схемы) создают сырые данные и взаимодействуют с ними.

Но есть одна главная особенность сырых данных - их можно упаковывать в объекты, а также распаковывать из объекта сырые данные. Об этом в следующей главе.

## Объект

*Речь не про объекты классов в C#*

Объект - обёртка из метаданных над сырыми данными в куче.
Объект состоит из:
- InstanceCache - это, так называемый, SyncBlockIndex (индекс блока синхронизации), размером с IntPtr. На самом деле это место может использоваться не только для хранения индекса блока синхронизации, но и для кэширования хэш-кода, пометок GC, финализации, также там содержаться флаги для определения того что там конкретно лежит. Можно даже самому использовать это место в unsafe коде для своих нужд.
-  SchemePtr - это ссылка (IntrPtr указатель) на тип (схему) или, так называемая, структура - MethodTable, которая содержит метаданные, статические поля и методы. В целом это тоже объект.
- Value - это сырые данные, которые рассматривались выше.

Объект обычно расположен в куче, а указатель на него в стэке или той же куче.
Сам по себе указатель на объект - это сырые данные, как и указатель на сырые данные.

Указатель на объект указывает на адрес указателя SchemePtr (таблицы методов) в куче. Т.е получается такая схема:
Стэк:
- Указатель на SchemePtr
Куча:
- (-8 байт смещение) InstanceCache
- (0 байт смещение) SchemePtr
- (+8 байт смещение) Value
> [!Info] Смещение 8 байт только на x64 битной архитектуре, используйте `IntPtr.Size`, чтобы не зависеть от архитектуры

Используя этот указатель и смещения, мы можем получить доступ к InstanceCache и Value.

Всё это примерно выглядит вот так на x64:

```cs
struct Object
{
    public long SyncBlockIndex; // InstanceCache, int for x32
    public MethodTable* MethodTablePtr; // SchemePtr/TypeHandle
    public RawData Data; // Value, raw data in object (field values)
}
struct RawData
{
	public byte Data; // Start point
}
```

Или более наглядный пример:

```cs
class MyClass { public int Id; }
// object layout
struct ObjectLayoutForMyClass
{
	public long SyncBlockIndex;
    public MethodTable* MethodTablePtr;
    public int Id;
}
```

Становится ещё понятнее, что объект - это сырые данные (часть которых скрыта от наших глаз) в куче, и на эти данные мы имеем указатель, который указывает на `SchemePtr`.

В итоге объект - это упакованные сырые данные (Value).
Также объекты можно распаковывать (unbox) в сырые данные, копированием сырых данных объекта в стэк. Как и сырые данные, которое могут быть упакованы (box) в объект, путём создания объекта в куче и копированием туда сырых данных.
Для упаковки нам нужно знать под какой тип (схему) оборачивать объект.

Приведение типов не существует, схемы не меняются после создания объекта, просто во время компиляции вставляется сигнатура `<Тип>::<Метод>` для вызова метода. А вот уже во время вызова метода (в runtime) используется таблица методов объекта, чтобы найти переопределённый метод (если есть), благодаря чему достигается полиморфизм подтипов.

Объекты стоит использовать, когда размер сырых данных превышает размер двух указателей по 4 байт (для x32) и 8 байт (для x64) соответственно.
Стоит использовать при малом количестве инстансов, большой времени жизни объектов или при построении сложного графа объектов.

Однако никто нам не мешает использовать boxed вариант сырых данных в виде объекта, тем самым контролируя когда сырые данные боксить (превращать в объект), а когда нет, если быстрее будет копировать, но контролировать это дело не просто, поэтому к такой экзотике лучше не прибегать. Да и по большему счёту если нам не нужны `SyncBlockIndex` и `MethodTablePtr`, то можно обойтись без боксинга, но при этом хранить данные в куче и использовать ref-ы на эту память, однако в таком случае нужно будет самому аллоцировать и чистить память, со стэком же всё куда проще, но без преимуществ кучи, конечно.

#### Создание объекта

Обычно все инстансы объектов создаются через оператор new, и вот что происходит:
1. Вычисление кол-ва байт для хранения полей + у объектов в куче дополнительно добавляются байты для указателя на объект-тип (схему, type object pointer) и для индекса блока синхронизации (sync block index / InstanceCache).
2. Выделение памяти для объекта с резервированием необходимого кол-ва байт в управляемой куче. Выделенные байты инициализируются нулями.
3. Инициализация указателя на объект-тип (схему) и индекса блока синхронизации.
4. Вызов конструктора (newobj instance) у экземпляра типа с параметрами, указанными при вызове new:
    1. Компилятор обычно (но не для ValueType/структур) вставляет в начале каждого конструктора вызов конструктора базового типа, включая пустой конструктор у Object.
    2. Затем компилятор вставляет инициализацию полей, а потом уже идёт код в конструкторе.
       Используемые в конструкторе поля инициализируются значением по умолчанию.
5. new возвращает ссылку (указатель) на созданный объект.

## Поля

Что такое поля? Вы можете предположить, что это сырые данные, но нет. Это метаданные для сырых данных. Минимальный джентльменский набор: схема(тип поля) и название. Этого достаточно, чтобы объяснить зачем они нужны и как используются на сырых данных.

Можно сказать, что поле - это сигнатура для вычленения данных из массива сырых данных.
Благодаря типу (схеме) и названию поля, т.е благодаря сигнатуре поля мы можем получить размер требуемых данных, а также тип (схему) данных.

Когда мы обращаемся к полю, используется инструкция вида - `ldflda int32 MyStruct::MyField`, которая принимает в качестве аргумента сырые данные (лежит наверху стэка) и с помощью сигнатуры возвращает адрес на ту часть, которую мы хотим получить, либо есть вариант `ldfld`(без a), что возвращает копию данных поля, а не адрес.
В качестве размера данных выступает аргумент `int32`, а в качестве смещения аргумент `MyStruct::MyField`.
Указание сигнатуры происходит во время компиляции!

Когда мы задаём значение полю, используется инструкция вида - `stfld int32 MyStruct:MyField`, которая принимает в качестве аргументов адрес на сырые данные и данные, которые мы хотим записать. В остальном всё то же самое, по сигнатуре определяется размер и смещение, а сама сигнатура, как и инструкция вставляется во время компиляции.

Помимо этого, есть ещё аналогичные инструкции для `static` полей - `ldsfld` и `stsfld`.
Единственное отличие - это то, что нам не нужно передавать туда сырые данные, с которыми мы будем оперировать, т.к сырые данные берутся из типа (схемы) `MyStruct`.

Сами по себе `static` поля - это пометка, что эти сырые данные должны относится к самой схеме (типу), а не к его инстансу. Т.е существовать в единичном экземпляре.

Константные поля - это тоже `static` поля, но помеченные модификатор `literal`, который говорит о том, что значение поля задаётся только один раз, во время компиляции. Это даёт возможность компилятору инлайнить (сворачивать константы) значения в места их использования во время компиляции, не тратя время на получение значения.

Все инициализации полей в наших классах/структурах переезжают в начало всех конструкторов (`ctor`). Инициализация `static` полей переезжает в `static` конструктор (`.cctor`). По факту в [[CLR]] нет инициализации полей значениями, поэтому единственный способ это сделать - переместить её в начало всех конструкторов, что компилятор и делает во время компиляции.

Модификатор `readonly` (`initonly` в IL) запрещает изменять значение после инициализации (в конструкторе).

Модификатор `required` - фича компилятора, которая заставляет инициализировать поле через Object Initializer (синтаксис `new MyClass() { Value = 123 };`) или конструктор помеченный атрибутом `[System.Diagnostics.CodeAnalysis.SetsRequiredMembers]`. Для своей работы добавляет атрибут `[RequiredMemberAttribute]` на схему и поле, а к пустому конструктору по умолчанию добавляет атрибут `[Obsolete]` и `[CompilerFeatureRequired]`.

Модификатор `ref`, доступный только в `ref struct`, - позволяет хранить ссылку на сырые данные, вместо значения. Доступны только в `ref struct` не просто так, а потому что использовать такие ссылки безопасно можно только на стэке, `ref struct` гарантирует нахождение сырых данных на стэке. Такие особенности связаны с сборщиком мусора и автоматическим управлением памятью в CLR. С помощью unsafe кода мы можем использовать указатели, но тогда нам придётся самим следить за памятью, чтобы ссылки куда-то указывали и чтобы выделенная память очищалась.
Ещё на эти поля можно навесить модификаторы `readonly ref`, `ref readonly` и `readonly ref readonly`. Первое означает `readonly` для ссылки на значение, второе означает `readonly` для самого значения (ссылка может меняться), а третье - это всё вместе.

В итоге мы выяснили, что работа с полями похожа на работу с методами, но в облегчённом виде. Мы просто передаём сырые данные (Value) и получаем их кусочек, либо ссылку на их кусочек.

## Методы

Указатели на регион памяти с нативными инструкциями используются во время вызова метода, для упрощения, скажем что эти указатели хранятся в схеме (в таблице методов).

Изначально никаких нативных инструкций нет, есть лишь IL код в виде метаданных метода, но во время первого вызова JIT компилятор компилирует IL код в нативный, кэшируя указатель на область памяти со сгенерированным кодом (заменяя нативный переход на другой адрес).


//Вот тут есть вопросы к Линкуксу
Есть два основных способа вызова метода:
- `call instance <Схема>::<Метод>` - ищет в схеме, указанной при вызове, метод и передаёт туда сырые данные из стэка.
  Именно так, во время компиляции, вставляется вызов метода у сырых данных, т.к они не содержат метаданных, именно поэтому полиморфизм подтипов не применим к сырым данным. // спросить у линукса, почему недоступен
  Например вызов : 
- `callvirt instance <Схема>::<Метод>` - ищет сначала переопределённые методы нужной сигнатуры в схеме, а потом уже не переопределённые, как в обычном call.
  Именно этот вызов обычно применяется для всех объектов, т.к только они поддерживают переопределение методов благодаря указателю на схему (+в самой схеме указатель на родительскую схему), что позволяет определить какие методы мы можем вызывать и использовать методы родительских (в отношении нашей схемы) схем.
  Туда передаются тоже сырые данные, но уже в виде ссылки (указателя) на наш объект.
  Например вызов: 
- Ещё есть `call` и `callvirt` вызовы без `instance` - всё то же самое, но сырые данные берутся из самого типа (схемы), т.е в метод передаётся ссылка на схему (тип). // нужен пример
  Такие вызовы используются для статических (`static`) методов. Статические методы - это обычные методы, которые применяются к сырым данным, только в данном случае под видом сырых данных используется ссылка на схему (тип).

Методы можно писать не только во время компиляции, но и в рантайме.
Используя unsafe код можно сильно не прибегать к рефлексии, если производительность важнее безопасности типов.

Методы поддерживают ad hoc полиморфизм - перегрузку методов (одинаковые имена, но разные параметры). Вариант метода выбирается во время компиляции.

Методы могут принимать и возвращать любые сырые данные.

По умолчанию короткие (<=32byte size) методы инлайнятся (код метода вставляется в место вызова) во время компиляции.
Длинные методы не инлайнятся по умолчанию, т.к это может сильно увеличить количество инструкций, особенно если вызовов много, что в итоге приводит к снижению эффективности кэша процессора, в таких случаях будет быстрее вызвать метод.
На самом деле условий инлайнинга больше, JIT принимает решение на основании многих параметров (например, сложность типов данных передаваемых в метод, или сложность конструкций в методе). Есть атрибуты `[MethodImpl(MethodImplOptions.AggressiveInlining)]` и `[MethodImpl(MethodImplOptions.NoInlining)]`, которые используются для ручного указания, но в большинстве случаев лучше оставлять поведение по умолчанию, компилятор достаточно умён, чтобы понять, когда стоит инлайнить, а когда нет.

#### Generic методы

Существуют ещё generic методы или же templatе методы, которые предоставляют нам механизм статического полиморфизма.
Мы можем написать метод, который работает с разными типами, как если бы он работал с одним.

Это мета-программирование, которое поддерживает CLR в runtim-е, даже в том же IL коде будет один template метод, т.е его компиляция под конкретный тип уже происходит в runtim-е, во время его первого использования с определённым типом (схемой).

Ещё одна интересная особенность - новый метод генерируется JIT-ом только для новых форм сырых данных, а для старых используются уже созданные, кэшированные. Т.е для `int` и `long` будут сгенерированы разные методы, а для `string`, `object`, `MyClass` нет - они имеют одинаковую форму сырых данных - ссылку размером IntPtr и принцип работы с ними будет одинаковый для них всех. Поэтому для любых ссылок сгенерируется один метод в котором используется тип `System.__Canon`, а для других сырых данных сгенерируется отдельно по методу.

```csharp
public class Program
{
    // Используем атрибут SharpLab для указания типов JIT-компиляции
    [SharpLab.Runtime.JitGeneric(typeof(int)), SharpLab.Runtime.JitGeneric(typeof(string)),SharpLab.Runtime.JitGeneric(typeof(MyClass))]
    public static void PrintType<T>(T value)
    {
        if (value is string)
        {
            Console.WriteLine("It's a string: " + value);
        }
        else if (value is MyClass)
        {
            ((MyClass)(object)value).Print();
        }
        else
        {
            Console.WriteLine("It's a type: " + value.GetType().Name);
        }
    }

    [SharpLab.Runtime.JitGeneric(typeof(int)), SharpLab.Runtime.JitGeneric(typeof(long))]
    public static void PrintStructType<T>(T value)
    {
        if (value is int)
            Console.WriteLine("It's an int: " + value);
        if (value is long)
            Console.WriteLine("It's a long: " + value);
    }

    public static void Main()
    {
        // Вызовы метода
        PrintType("Hello, world!");
        PrintType(new MyClass());
        PrintStructType(42);
        PrintStructType(10000000000L);
    }
}
```

JIT код, тут и можно увидеть что наш метод для всех ссылочных типов данных использует 
``` csharp 
Program.Main()
    L0000: push ebp
    L0001: mov ebp, esp
    L0003: mov ecx, [0x92dc7fc]
    L0009: mov edx, 0x30c0cc38
    L000e: call Program.PrintType[[System.__Canon, System.Private.CoreLib]](System.__Canon)
    L0013: mov ecx, 0x30c0c710
    L0018: call 0x06a8300c
    L001d: mov ecx, eax
    L001f: mov edx, 0x30c0ccc8
    L0024: call Program.PrintType[[System.__Canon, System.Private.CoreLib]](System.__Canon)
    L0029: mov ecx, 0x2a
    L002e: call Program.PrintStructType[[System.Int32, System.Private.CoreLib]](Int32)
    L0033: push 2
    L0035: push 0x540be400
    L003a: call Program.PrintStructType[[System.Int64, System.Private.CoreLib]](Int64)
    L003f: pop ebp
    L0040: ret
```

Ещё одна особенность - это вызов метода у сырых данных без упаковки, если generic метод, в котором мы находимся ограничен (constraint - `where T : MyClass, IMyInterface`), таким образом мы точно знаем, во время компиляции, что передаваемые сырые данные поддерживают определённые методы, поэтому можем вызывать их без упаковки в объект. 

Из этого следует всегда задумываться стоит ли делать аргументы в виде интерфейса, что приведёт к упаковке, когда будем передавать сырые данные, а не ссылку на объект:
```cs
void Method(IMyInterface myInterface) {}
```
Либо же использовать generic-и, которые позволяют писать код без упаковок:
```cs
void Method<T>(T @object) where T : IMyInterface {}
```
Для ссылок будет использоваться один метод (подобный первому выше), а для сырых данных свой для каждого типа (схемы).
В следующий раз задумайтесь над этим, когда будете писать метод, который принимает интерфейс в качестве аргумента.

#### Extension методы

Методы расширения - это по большей части сахар компилятора, методы расширения позволяет вызывать сторонние методы так, как будто мы вызываем методы объекта.

Метод расширения - это просто статический метод в каком-то классе. Благодаря первому аргументу с модификатором `this` компилятор понимает что это метод расширения и добавляет ему атрибут `[Extension]`, что позволяет IDE добавлять подсказки в IntelliSense для вызова метода.

После компиляции наш вызов `obj.ExtensionMethod()` превращается в `ExtensionClass.ExtensionMethod(obj)`.

#### Конструкторы

Интересно, что конструкторы являются обычными методами, которые предоставляют логику инициализации сырых данных после их создания. Однако конструкторы не обязательны.
Обычные `instance` конструкторы имеют техническое название `.ctor`, `static` конструкторы имеют название `.cctor`.
Все они имеют специальные модификаторы методов - `specialname` `rtspecialname`, чтобы компилятор и [[CLR]] определяли что это конструктор.

#### Operator методы

// TODO

#### Аргументы методов

В методы мы всегда по умолчанию копируем сырые данные из стэка, будь это ссылка или сырые данные (ссылка - это тоже сырые данные). Передавая объект, передаётся копия ссылки на него, что тоже является сырыми данными.

Мы можем задать модификатор `ref` для аргумента, что позволит нам получить не копию сырых данных, а ссылку на эти сырые данные. Всё также работает и для объектов! Для них мы получаем ссылку на ссылку 🥴

Что же происходит, когда мы используем модификатор `in`?
Всё то же самое! Даже `in` заменяется на `ref`, но компилятор добавляет пару атрибутов. Для нас важен атрибут `[In]`, который запрещает установку значений по этой ссылке, только чтение. Однако, если мы передаём ссылку на ссылку, то мы можем прочитать ссылку и получить ссылку на объект, по которой можем его модифицировать. Менять нельзя только верхнюю ссылку, которую мы непосредственно передаём в аргументы!

А зачем тогда нужен модификатор `readonly ref`?
Интересно, но это тот же самый модификатор `in`, но более современный аналог, предполагается сейчас использовать именно его. Он заменяет лишь один атрибут, который мы не будем рассматривать.
Но ключевая его особенность - это возможность использования в возвращаемых значениях метода. Т.е мы можем вернуть из метода не просто сырые данные, а ссылку на эти сырые данные. Например, ссылку на элемент из массива.

Как тогда работает `out`?
Это тот же `ref`, но с атрибутом `out`, который заставляет установить значение по этой ссылке хотя бы раз. Может использоваться как способ возвращения значения из метода. Теперь представим как это работает с объектом в типичной практике: передаём ссылку на пустую ссылку (null), в методе по ссылке меняем пустую ссылку (null) на новый, созданный объект.

Модификатор `params` используется как синтаксический сахар для массивов, чтобы мы могли создавать массив прямо во время вызова метода, передавая туда бесчисленное количество аргументов (именно поэтому аргумент с этим модификатором должен быть последним аргументом). [[CLR]] не знает ничего об этом модификаторе, очередной сахар компилятора, который превращается в создание массива перед вызовом метода и его передачу.
Однако есть интересная фича, если мы вызываем пустой метод (без элементов в массиве), то он передаст `Array.Empty<T>()` (кэшированную версию массива без элементов, в единственном экземпляре), что довольно-таки полезно!

В новых версиях C# мы можем использовать Span/ReadOnlySpan с модификатором `params`, однако пустая версия вызова будет использовать `default(Span)` (пустой спан), а версия с параметрами будет создавать структуру в техническом классе `'<PrivateImplementationDetails>'` основываясь на типе (размер и выравнивание) и создаст `static readonly` поле типа этой структуры, в метаданных которого будут значения передаваемые в параметры в виде массива. Похоже на Inline Arrays, который кстати размещает статические методы по работе с такими массивами (структурами) в этот же технический класс.

Модификатор `scoped` применяется к `ref` аргументам, но смысл в использовании есть только с `ref struct`-ами. Этот модификатор добавляет атрибут `[ScopedRef]` к аргументу, что в свою очередь говорит компилятору, что этот аргумент не может выйти из этого контекста, т.е мы не сможем вернуть этот `ref` из метода или расположить где-то ещё. Если метод какого-нибудь `ref struct`-а принимает в качестве аргумента `ref struct`, то компилятор будет ругаться, что возможна утечка ссылки т.к `ref struct`-ы могут иметь `ref` поля, явно указанный модификатор `scoped` решит проблему с вызовом такого метода.
Ещё интересно, что `scoped` может применятся как модификатор для локальной переменной в методе.

Интересные атрибуты аргументов метода, которые могут заменить вам рефлексию:
1. `[CallerMemberName] string memberName` - позволяет получить строку с именем метода, который вызвал наш метод. При компиляции просто вставляет во все вызовы методов `nameof(ИмяМетода)`, в итоге макрос `nameof` при компиляции вставляет строку с названием метода.
2. `[CallerArgumentExpression(nameof(myArgument))] string expression` - то же самое, что и атрибут выше, но возвращает строковое выражение, которое ты передаёшь во время вызова метода в аргументе `myArgument`. Т.е если ты вызовешь метод, передавая в `myArgument` значение `1 + 1`, то в `expression` вставится строка `1 + 1` (вставляется во время компиляции).
3. `[CallerFilePath] string filePath` - возвращает путь к файлу, где находится метод вызывающий наш метод. Естественно путь встраивается в виде строки во время компиляции.
4. `[CallerLineNumber] int lineNumber` - возвращает номер строки в файле, где находится вызов нашего метода. Номер строки тоже встраивается во время компиляции.

#### Модификаторы методов

`virtual` - создаёт новый слот (`newslot`) c `virtual` методом в схеме. `newslot` нужен для перекрытия/скрытия базовых виртуальных методов с той же сигнатурой.
Модификатор `virtual` позволяет переопределять (`override`) метод в производных схемах.

`override` - не создаёт новый слот, но неявно добавляет модификатор `virtual` к методу. Принцип вызова таких методов с помощью `callvirt` был описан выше.
Не путать с `.override method` в IL, который биндит метод в другую схему, это используется в методах с явной имплементацией интерфейса (т.е явная имплементация переносит метод в другую схему).

`abstract` - то же самое что и `virtual`, но метод не содержит имплементации по умолчанию, а переопределение этого метода обязательно (иначе ошибка во время компиляции).

`extern` - позволяет импортировать функции из нативных библиотек, например, с помощью атрибута `[DllImport("dllpath", charset)]`.
Но по факту он предоставляет нам возможность декларировать метод без его имплементации. Мы можем сделать метод `virtual extern`, что позволит нам получить `virtual` метод без имплементации по умолчанию. Как `abstract`, но без требования имплементировать метод. Однако если у метода не будет имплементации (пустое тело), то вызов такого метода приведёт к ошибке в runtime ⚠️

`sealed` (`final` в IL) - запечатывает метод, такой метод нельзя переопределить в наследниках. Этот модификатор применим только к `virtual` методам. Он по умолчанию применяется в имплементации интерфейса, чтобы его убрать нужно добавить к имплементации модификатор `virtual`. В остальных случаях может использоваться только с модификатором `override`, что довольно-таки логично.

`partial` - чисто фича компилятора, работающая в `partial class, struct, interface, record`, позволяющая определить сигнатуру метода без реализации и без модификаторов доступа, полагая что реализация будет определена в другом файле этого же типа, но не обязательно (можно определить имплементацию там же, где и декларация). Обычно используется совместно с генераторами кода, вторая часть типа генерируется. Например, в WinForms.
Следует отметить, что к свойствам модификатор `partial` также применим.

#### Интересные атрибуты методов

1. `[IsReadOnly]` - говорит компилятору, что метод не изменяет значений, особенно полезно в структурах. Это позволяет выдавать ошибку в методе, если вы пытаетесь что-то изменить, а также даёт возможность JIT-у скомпилировать более эффективный код, не копируя лишний раз сырые данные. Интересно, что многие методы в `struct record`-ах помечены этим атрибутом. // TODO readonly method modifier
2. `[Obsolete]` - выдаёт предупреждение в IDE, что метод устаревший. В атрибуте можно писать комментарии.
3. `[SkipLocalsInit]` - применяется не только для методов, но и для `class/struct/module` (не применим для `assembly`), распространяет своё влияние на все вложенные методы. Атрибут убирает инициализацию локальных переменных нулями в методах, особенно полезно для больших структур или аллокаций на стэке (`stackalloc`), тогда нам не нужно дополнительно заполнять память нулями, однако тогда у нас будут рандомные значения, лежавшие раньше в памяти, в большинстве случаев это не играет роли, т.к мы потом сами ставим значения. Требует включения `AllowUnsafeBlocks` в настройках проекта.
4. // TODO

## Схема

*Речь не про классы в C#*

Class/Type/Scheme/Схема - это нативный объект, в единственном экземпляре, который представляет из себя метаданные, для упрощения скажем что и ссылки на методы (в реальности всё сложнее).

Т.к схема - объект, у неё есть InstanceCache (SyncIndex), SchemePtr (MethodTablePtr) и Value (сырые данные). Можно догадаться, что в сырых данных лежит вся "статика".

В IL коде описание схемы - это `.class`.
В C# любой класс, интерфейс, структура, enum, делегат - это описание схемы или же `.class`, или же тип.

Описание схемы содержит метаданные в виде сигнатур методов с их байткодом (IL), поля и их структуру, свойства, события, атрибуты, имплементации интерфейсов (+карта интерфейсов), путь до базовой схемы, а также вложенные (nested) схемы.

При первом обращении к схеме, создаётся объект схемы на основании описания схемы (`.class`). Сама схема (объект) будет находиться в loader heap, который живёт весь domain и не обрабатывается [[GC]].
Вспомните статические классы или поля, теперь догадываетесь как они работают?

Т.е статика - это модификатор, который разделяет методы/поля обычного объекта от схемового объекта во время компиляции.
Получается, что схема может содержать `instance` и `static` члены, соответственно при определении этих членов мы указываем `instance` это или `static`.

Схема может иметь схему, расширять её функционал (`extends`). Если говорить более предметно, у этого класса **может быть** базовый, но только один, множественное наследование не предусмотрено.
С помощью этого механизма мы получаем полиморфизм подтипов, доступ к членам базового класса, возможность переопределять поведение базового класса.

Помимо расширения (`extends`) схема может имплементировать (`implements`) неограниченное количество схем (предполагаются интерфейсы). Практически то же самое, что и расширение, но расширять и переопределять можно только методы.

#### Модификаторы схем

`sealed` - запечатывает схему, такую схему нельзя расширять (`extends`) и имплементить (`implements`). Любые классы/интерфейсы с модификатором `static`, а также любые структуры превращаются в `sealed` схемы во время компиляции.

`abstract` - делает схему абстрактной, объект такой схемы нельзя создать. Обычно служит для базовых схем или схем, которые ты имплементируешь (интерфейсы).

`interface` - указывает что схема является интерфейсом, именно такие схемы можно имплементировать. Этот модификатор нужен для внутренних механизмов [[CLR]], чтобы обеспечивать правильную работу `implements`, ну и чтобы можно было отличить обычный класс от интерфейсного. Также это даёт понять, что мы не можем расширять (`extends`) класс и содержать `instance` поля. Поэтому, можно сказать, что в [[CLR]] интерфейсы тоже есть.

Layout модификаторы, которые определяют метаданные для полей (их смещения, размер), чтобы эффективно упаковывать сырые данные в памяти:
- `auto` - [[CLR]] самостоятельно определяет выравнивание данных. Этот модификатор стоит на большинстве схем по умолчанию (кроме структур из C#, которые используют `sequential` для схемы).
- `sequential` - выравнивает данные в таком порядке, в каком они определены в схеме. Обычно используется для маршлинга (мапинга памяти из/в натив), чтобы гарантировать порядок.
- `explicit` - требует явного указания смещения полей (в C# через атрибут `[FieldOffset(int)]`).
Все эти модификаторы для схемы в C# задаются через атрибут `[StructLayout(LayoutKind)]`.

#### Generic схемы

// TODO

#### MethodTable

Так называемая таблица методов, на самом деле legacy название, от методов там мало что осталось. В основном там хранятся те самые _hot_ метаданные (_cold_ хранятся в `EEClass`).

```cs
[StructLayout(LayoutKind.Explicit)]
unsafe struct MethodTable
{
    /// <summary>
    /// The low WORD of the first field is the component size for array and string types.
    /// </summary>
    [FieldOffset(0)]
    public ushort ComponentSize;

    /// <summary>
    /// The flags for the current method table (only for not array or string types).
    /// </summary>
    [FieldOffset(0)]
    public uint Flags;

    /// <summary>
    /// The base size of the type (used when allocating an instance on the heap).
    /// </summary>
    [FieldOffset(4)]
    public uint BaseSize;
    
    // See additional native members in methodtable.h, not needed here yet.
    // 0x8: m_dwFlags2 (additional flags and token in upper 24 bits)
    // 0xC: m_wNumVirtuals
    
    [FieldOffset(8)]
    public uint DWFlags2;
    
    [FieldOffset(12)]
    public ushort VirtualsCount;

    /// <summary>
    /// The number of interfaces implemented by the current type.
    /// </summary>
    [FieldOffset(14)]
    public ushort InterfaceCount;

    // For DEBUG builds, there is a conditional field here (see methodtable.h again).
    // 0x10: debug_m_szClassName (display name of the class, for the debugger)

    /// <summary>
    /// A pointer to the parent method table for the current one.
    /// </summary>
    [FieldOffset(16)]
    public MethodTable* ParentMethodTable;
    
    // Additional conditional fields (see methodtable.h).
    // m_pModule
    [FieldOffset(24)]
    public IntPtr ModulePtr;

    /// <summary>
    /// A pointer to auxiliary data that is cold for method table.
    /// </summary>
    [FieldOffset(32)]
    public MethodTableAuxiliaryData* AuxiliaryData;
    
    // union {
    //   m_pEEClass (pointer to the EE class)
    //   m_pCanonMT (pointer to the canonical method table)
    // }
    [FieldOffset(40)]
    public IntPtr EEClassPtr;

    // union {
    //   ElementType
    //   InterfaceMap
    // }
    /// <summary>
    /// This element type handle is in a union with additional info or a pointer to the interface map.
    /// Which one is used is based on the specific method table being in used (so this field is not
    /// always guaranteed to actually be a pointer to a type handle for the element type of this type).
    /// </summary>
    [FieldOffset(48)]
    public void* ElementType;
    
    /// <summary>
    /// This interface map used to list out the set of interfaces. Only meaningful if InterfaceCount is non-zero.
    /// </summary>
    [FieldOffset(56)]
    public MethodTable** InterfaceMap;
    
    [FieldOffset(64)]
    public void* VTableFirstEntry;
}

[StructLayout(LayoutKind.Explicit)]
unsafe struct MethodTableAuxiliaryData
{
    [FieldOffset(0)]
    private uint Flags;

    private const uint enum_flag_CanCompareBitsOrUseFastGetHashCode = 0x0001;     // Is any field type or sub field type overrode Equals or GetHashCode
    private const uint enum_flag_HasCheckedCanCompareBitsOrUseFastGetHashCode = 0x0002;  // Whether we have checked the overridden Equals or GetHashCode

    public bool HasCheckedCanCompareBitsOrUseFastGetHashCode => (Flags & enum_flag_HasCheckedCanCompareBitsOrUseFastGetHashCode) != 0;
    public bool CanCompareBitsOrUseFastGetHashCode => (Flags & enum_flag_CanCompareBitsOrUseFastGetHashCode) != 0;
}
```

// TODO
## System.Type

`System.Type` - объект из этой схемы позволяет получить доступ к самым важным частям метаданных любой схемы, а также позволяет получить более продвинутую версию `TypeInfo`, в которой есть практически все метаданные.

Рефлексия в чистом виде, обёртка над внутренними механизмами CLR для управления из C#.

## System.Object

Это схема, которая может быть применена практически к любому объекту, с помощью приведения типов, т.к схема практически любого объекта наследуется от схемы `System.Object`. Поэтому можно сказать, что System.Object - это корневая схема для всех остальных схем.

Следует отметить, что у этой схемы нет базовой (ссылка на родительскую схему пустая).

Также эта схема является маркером, что инстансы этой схемы должны быть объектами, а не сырыми данными. В IL коде такие пользовательские схемы (типы) помечаются меткой `class`, например в аргументах метода или полях можно увидеть что-то вроде этого - `class MyClass/MyInterface/MyDelegate`.

У схемы есть методы:
- virtual Equals (true если 2 объекта одинакового значения).
- virtual GetHashCode - по умолчанию возвращает (m_dwHashCodeSeed = m_dwHashCodeSeed * (ThreadId * 4 + 5) + 1) >> (32 - 26), т.е ThreadId умноженный на рандомное число, после этого хэшкод для кэширования сохраняется в поле InstanceCache (SyncBlockIndex, который по умолчанию без блокировок равен 0), либо в хедер с флагами в зависимости от того используется ли индекс блока синхронизации или нет.
- virtual ToString (по умолчанию GetType().ToString()).
- virtual Finalize (вызывается при сборке этого объекта [[GC]]) - это наш обыденный деструктор.

- GetType - возвращает обёртку над схемой для получения метаданных в рантайме в виде System.Type, для доступа к механизмам рефлексии.
- MemberwiseClone - создание пустого объекта и копирование всех полей в него, по сути просто клонирование средствами unsafe.
- .ctor - пустой конструктор без параметров, который обычно вызывается (вызов добавляется во время компиляции) в конструкторах всех схем, у которых схема System.Object базовая, но после инициализации полей.

## System.ValueType

Представляет из себя схему, у которой базовая схема - System.Object. Основной смысл существования этой схемы - это маркировка для компилятора и переопределение методов из System.Object для корректной работы с сырыми данными.
Эта схема является базовой для struct и System.Enum, но к сожалению в C# мы не можем наследоваться от System.ValueType напрямую.

Интересно, что в IL коде пользовательские схемы (типы) помечаются меткой `valuetype`, например в аргументах метода или полях можно увидеть что-то вроде этого - `valuetype MyStruct/MyEnum`.

Методы из System.Object предполагают что вы используете объекты и сравниваете их по ссылке, а не по значению, предполагается что и хэшкод тоже не зависит от значения.

Но чтобы удобно работать с сырыми данными, сравнивать куски данных по значению или вычислять хэшкод, была придумана схема System.ValueType.

Если немного погружаться в детали имплементации, то бывают простые и сложные сырые данные, по большей части именно с точки зрения сравнения по значению. Это определяется для выбора оптимальной (по производительности) стратегии вычисления хэшкода или сравнения.

Простые сырые данные - это просто куски данных без какой-либо логики, данные условия применимы к struct и enum:
- Нет ссылочных полей (т.к ссылочные поля требуют отдельного сравнения и получения хэшкода через виртуальный метод, нельзя сравнивать по ссылке или получать хэшкод ссылки)
- Без полей с плавающим числом (float, double, т.к казалось бы одинаковые числа могут быть разными + они имеют свою имплементацию Equals и GetHashCode).
- Без пробелов между полями, т.е у простых сырых данных должно быть плотное нормальное выравнивание.
- Equals и GetHashCode не переопределены.

ValueType в свою очередь всего лишь переопределяет методы:
- Equals - быстрый memcmp (сравнение по сегменту памяти), если структура простая, иначе использует рефлексию для сравнения каждого поля по-отдельности.
- GetHashCode состоит из добавленных байтов в HashCode:
    1. Указателя на индекс класса (указатель на таблицу с методами - SchemePtr).
    2. Как и в случае с Equals проверяется является ли структура простой, если да, то просто добавляем все её байты в виде сырых данных в HashCode.AddBytes.
       ==⚠️ Иначе мы просто добавляем байты первого поля, а остальные игнорятся!!!==
- ToString (GetType().ToString()) - переопределено, чтобы компилятор не боксил сырые данные в объект, используя версию из System.Object (помним что компилятор использует Object и ValueType как маркер).

Может показаться, что стоит делать простые структуры для повышения производительности, ничего не переопределяя. Но это не так. Сами по себе проверки флагов, условия и валидация могут занимать много времени, даже если код будет идти по быстрому пути.
==Поэтому лучше всего переопределять Equals и GetHashCode==, если это требуется, что в несколько сотен раз быстрее по перфомансу (в наносекундах естественно).

## Class

Класс в C# - это инструмент написания схем (`.class`) в [[CLR]], но не простых схем, а схем, у которых базовая схема это System.Object. Грубо говоря, у компилятора есть шаблон, по которому он генерирует схемы в IL, основываясь на параметрах, которые ты задаёшь.

Однако пометка `class` не просто генерирует код по шаблону, но ещё и представляет из себя маркер для компилятора, что позволяет ему определиться как работать с этими инстансами (как с сырыми данными или как с объектами) и как их создавать. В данном случае эта пометка означает, что инстансы этой схемы будут использоваться как объекты, а не как сырые данные. Т.е инстанс класса - это объект, на который мы потом будем ссылаться.

Пустой шаблон класса выглядит примерно так:
```cs
// Empty C# class
class MyClass;
// Converted to IL
.class private auto ansi beforefieldinit MyClass
    extends [System.Runtime]System.Object
{
    .method public hidebysig specialname rtspecialname 
        instance void .ctor () cil managed 
    {
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: call instance void [System.Runtime]System.Object::.ctor()
        IL_0006: ret
    }
}
```

Особенности шаблона класса в C#:
- Инстансы этого шаблона маркируется для компилятора как объект, а сам шаблон порождает объекты.
- По умолчанию всегда расширяем (`extends`, наследуемся) от System.Object.
- Всегда имеем конструктор, но при желании можно явно задать приватный конструктор без параметров.
- Во всех конструкторах после инициализации полей идёт вызов конструктора из базовой схемы.
- По умолчанию выравнивание сырых данных стоит в режиме `auto`.
- Классы с модификатором `static` превращаются в `abstract sealed` классы, а все ограничения связанные с `static` классами накладывает по большей части именно компилятор.
- Может иметь модификаторы: `static, abstract, sealed, partial, readonly`.
- Не может иметь виртуальных статических методов.
- Может иметь деструктор (можно переопределять метод Finalize).

Модификатор `readonly`, добавляет атрибут `[IsReadOnly]` и заставляет добавить модификатор `readonly` (`initonly`) всем полям, которые должны быть проинициализированы в конструкторе, без дальнейшей возможности изменения. Это можно рассматривать как поддержка иммутабельности у объектов.

Модификатор `partial` - чисто фича компилятора, позволяющая разделять один `class, struct, interface, record` на разные части в разных файлах, но по итогу всё склеится в один. Работает он также на всех вышеприведённых шаблонах, и работает только на них. Ещё это позволяет использовать модификатор `partial` для методов и свойств, разделяя декларацию и имплементацию, обычно для кодогенарторских утех.

## Interface

> [!Info] Интерфейсы определяют контракт, который класс должен реализовать.

Самое интересное, что интерфейсы в C# превращаются в абстрактные классы, помеченные модификатором `interface`. В данном случае это не только пометка для компилятора, но и для [[CLR]]. О модификаторе `interface` я писал выше в главе Схема.

Шаблоны интерфейса разворачиваются примерно в такой код:
```cs
// C#
interface MyEmptyInterface;
interface MyInterface { int MyContractMethod(); }

class MyEmptyClass : MyEmptyInterface;
class MyImplicitlyClass : MyInterface { public int MyContractMethod() => 0; }
class MyExplicitlyClass : MyInterface { int MyInterface.MyContractMethod() => 1; }
class MyDoubleClass : MyInterface
{
	public int MyContractMethod() => 0;
	int MyInterface.MyContractMethod() => 1;
}
// Converted to IL
.class interface private auto ansi abstract beforefieldinit MyEmptyInterface { }
.class interface private auto ansi abstract beforefieldinit MyInterface
{
    .method public hidebysig newslot abstract virtual 
        instance int32 MyContractMethod () cil managed { }
}
.class private auto ansi beforefieldinit MyEmptyClass
    extends [System.Runtime]System.Object
    implements MyEmptyInterface { }
.class private auto ansi beforefieldinit MyImplicitlyClass
    extends [System.Runtime]System.Object
    implements MyInterface
{
    .method public final hidebysig newslot virtual 
        instance int32 MyContractMethod () cil managed 
    {
        .maxstack 8
        IL_0000: ldc.i4.0
        IL_0001: ret
    }
}
.class private auto ansi beforefieldinit MyExplicitlyClass
    extends [System.Runtime]System.Object
    implements MyInterface
{
    .method private final hidebysig newslot virtual 
        instance int32 MyInterface.MyContractMethod () cil managed 
    {
        .override method instance int32 MyInterface::MyContractMethod()
        .maxstack 8
        IL_0000: ldc.i4.1
        IL_0001: ret
    }
}
.class private auto ansi beforefieldinit MyDoubleClass
    extends [System.Runtime]System.Object
    implements MyInterface
{
    .method public hidebysig 
        instance int32 MyContractMethod () cil managed 
    {
        .maxstack 8
        IL_0000: ldc.i4.0
        IL_0001: ret
    }
    .method private final hidebysig newslot virtual 
        instance int32 MyInterface.MyContractMethod () cil managed 
    {
        .override method instance int32 MyInterface::MyContractMethod()
        .maxstack 8
        IL_0000: ldc.i4.1
        IL_0001: ret
    }
}
```

Особенности шаблона интерфейса в C#:
- Инстансы этого шаблона маркируется для компилятора как объект, а сам шаблон не может порождать объекты (модификатор `abstract`).
- Расширение (`extends`, наследование) запрещено, разрешена только имплементация (`implements`).
- `instance` поля и конструкторы запрещены (`static` поля и конструктор разрешён).
- По умолчанию выравнивание сырых данных стоит в режиме `auto`, но в данном случае это не имеет значения из-за отсутствия инстансов и `instance` полей.
- Может иметь модификаторы: `partial`.
- Может содержать только `virtual` методы/свойства/события (это относится только к `instance` методам).
- Может иметь статические виртуальные/абстрактные методы/свойства, но с ограничениями во время использования (компилятор заставит вас использовать generic-и и ограничения в виде этого интерфейса, т.к иначе он не поймёт какой вызов вставить во время компиляции).

По факту все методы в интерфейсе по умолчанию `abstract` (это раскрывается в `newslot virtual abstract`), что заставляет нас их имплементировать, однако мы можем имплементировать метод в интерфейсе (имплементация по умолчанию), тогда модификатор `abstract` уйдёт.

Из кода выше мы можем увидеть особенности неявной и явной имплементации интерфейса. Но у всех у них есть модификаторы `virtual` и `newslot`, что является требованием интерфейса, т.к он может содержать только виртуальные `instance` методы.

Однако можем заметить что в классе `MyDoubleClass` неявная реализация не имеет модификаторов `virtual` и `newslot`. Это происходит потому что этот метод не используется в интерфейсе и всегда вызывается напрямую.

Явно имплементированный метод интерфейса всегда будет иметь модификаторы `private sealed(final) newslot virtual` и пометку `override` в самом теле метода (реализации). Первое нужно для поддержания совместимости с интерфейсом, а модификатор `private` не даёт вызвать метод, который кстати и так сложно вызвать из-за его названия `MyInterface.MyContractMethod` (да, это название, компилятор будет ругаться на точку и уровень доступа, вызвать такой метод можно только через рефлексию).

А с модификатором `override` не всё так просто. Грубо говоря мы помечаем этот метод специально для вызова из определённого интерфейса и его метода, т.е название метода по сути роли не играет, а то откуда мы вызываем имлементацию определяется в `override`, у нас это: `.override method instance int32 MyInterface::MyContractMethod()`.

Неявная имплементация подразумевает собой имплементацию метода с той же сигнатурой и именем (в явной имя не роляет). Интересно, что это разворачивается в `virtual` `sealed` (по умолчанию, если не задан явно `virtual`) метод, т.к `virtual` (и `newslot`) являются требованием для имплементации интерфейса.
`callvirt` будет искать более подходящий метод, основываясь на контексте и метаданных. Мы можем даже ещё раз реализовать тот же интерфейс в наследниках, и всё будет работать прекрасно, т.к приоритетность вызова идёт от производных к базовым, однако если мы явно укажем базовый тип для производного объекта, то будет использоваться имплементация базового типа.

Интересно, что если мы имплементим интерфейс явно и неявно, то неявная часть отбрасывается, - это будет просто обычный, не виртуальный метод класса, не относящийся к интерфейсу. Даже если мы сделаем его `virtual`, то это не поможет, явная имплементация в приоритете.

Давайте посмотрим как выглядят вызовы:
```cs
interface MyInterface { int MyContractMethod() => -1; }
class MyImplicitlyClass : MyInterface { public int MyContractMethod() => 0; }
class MyExplicitlyClass : MyInterface
{
    public int MyContractMethod() => 0;
    int MyInterface.MyContractMethod() => 1;
}

public static void Main()
{
	var i = new MyImplicitlyClass();
	
	i.MyContractMethod(); // 0
	((MyInterface)i).MyContractMethod(); // 0

	var e = new MyExplicitlyClass();
	var m = e.GetType().GetMethod("MyInterface.MyContractMethod",BindingFlags.Instance|BindingFlags.NonPublic);
	
	e.MyContractMethod(); // 0
	((MyInterface)e).MyContractMethod(); // 1
	m.Invoke(e, null); // 1
}
// Converted to IL
.method public hidebysig static void Main () cil managed
{
	.maxstack 3
	.locals init (
		[0] class MyExplicitlyClass e
	)

	newobj instance void MyImplicitlyClass::.ctor()
	dup
	// MyImplicitlyClass::MyContractMethod call on object i
	callvirt instance int32 MyImplicitlyClass::MyContractMethod()
	pop
	// MyInterface::MyContractMethod call on object i
	callvirt instance int32 MyInterface::MyContractMethod()
	pop
	
	newobj instance void MyExplicitlyClass::.ctor()
	stloc.0
	
	ldloc.0
	callvirt instance class [System.Runtime]System.Type [System.Runtime]System.Object::GetType()
	ldstr "MyInterface.MyContractMethod"
	ldc.i4.s 36
	callvirt instance class [System.Runtime]System.Reflection.MethodInfo [System.Runtime]System.Type::GetMethod(string, valuetype [System.Runtime]System.Reflection.BindingFlags)
	
	ldloc.0 // on object e
	// MyExplicitlyClass::MyContractMethod call
	callvirt instance int32 MyExplicitlyClass::MyContractMethod()
	pop
	ldloc.0 // on object e
	// MyInterface::MyContractMethod call
	// override helps callvirt to find method implementation
	// in our case it's MyExplicitlyClass::MyInterface.MyContractMethod
	callvirt instance int32 MyInterface::MyContractMethod()
	pop
	ldloc.0 // on object e
	ldnull
	// MyExplicitlyClass::MyInterface.MyContractMethod reflection call
	callvirt instance object [System.Runtime]System.Reflection.MethodBase::Invoke(object, object[])
	pop
	ret
}
```

Как мы можем видеть, мы применяем `callvirt` с разной сигнатурой на один и тот же объект, грубо говоря указывая какой метод мы ищем.

Ещё раз закрепляем то, что никакого приведения типов нет, это существует только во время компиляции. Именно на основании ваших приведений и даже переменных с приведёнными типами (которых потом не существует) компилятор вставляет правильные вызовы.
Поэтому если вы пишете подобный код:
```cs
var mySuperClass = new SuperClass();
var myDisposable = mySuperClass;
var mySerializable = mySuperClass;
```
И думаете, что там действительно создаются переменные, то вы ошибаетесь. Здесь будет только один объект - `mySuperClass`. Всё остальное используется для объяснения компилятору того как работать с этим объектом.

Имплементация (`implements`) интерфейса от интерфейса происходит немного иначе, чем в классах/структурах, т.к нам не нужно имплементировать его, мы просто расширяем наш контракт.
Грубо говоря, если у нас есть интерфейс `IFoo : IOne, ITwo`, то он просто будет содержать ссылки на 2 схемы `IOne, ITwo`, в своей интерфейсной карте (грубо говоря массив). И когда мы имплементим `IFoo` в каком-нибудь классе, то вся интерфейсная карта `IFoo` + сам `IFoo` добавляется в интерфейсную карту схемы класса, в итоге класс должен имплементить все эти методы, вызов `callvirt` будет учитывать это при диспетчеризации.

В C#11 для интерфейсов появились `static virtual` методы/свойства/ивенты (+ работает `abstract`), для [[CLR]] особо ничего нового. По большей части это сделано для generic математики в виде переопределённых операторов. Раньше существовала большая проблема обобщённой работы с математикой. Например, если мы хотим складывать 2 числа, но при этом числа любых типов, которые поддерживают сложение между этими числами, нам приходилось самим писать кучу перегрузок для каждого типа. Для этого и много другого сейчас есть интерфейс `INumber` и многие другие, а также возможность создавать свои. Однако есть ограничение в виде generic-ов и строгой типизации. Т.е если мы хотим вызвать определённый вариант метода, то мы должны указать тип (какой вариант брать).

Вот небольшой пример `static virtual` с сложением чисел:
```cs
interface IAdditive<TSelf> where TSelf : IAdditive<TSelf>
{
    static abstract TSelf operator +(TSelf self, TSelf other);
}
readonly struct MyInteger : IAdditive<MyInteger>
{
    public readonly int Value;
    public MyInteger(int value) => Value = value;

    public static MyInteger operator +(MyInteger self, MyInteger other) =>
        new MyInteger(self.Value + other.Value);
}
readonly struct MyLong : IAdditive<MyLong>
{
    public readonly long Value;
    public MyLong(long value) => Value = value; 

    public static MyLong operator +(MyLong self, MyLong other) =>
        new MyLong(self.Value + other.Value);
}

public static void Main()
{
	var myInt1 = new MyInteger(1);
	var myInt2 = new MyInteger(2);
	
	var myIntResult = SomeAdd(myInt1, myInt2);
	Console.WriteLine(myIntResult.Value); // 6
	
	var myLong1 = new MyLong(2);
	var myLong2 = new MyLong(3);
	
	var myLongResult = SomeAdd(myLong1, myLong2);
	Console.WriteLine(myLongResult.Value); // 10
}
public static T SomeAdd<T>(T first, T second) where T : IAdditive<T>
{
	return first + second + first + second;
}
```

Смысл этой кабалы в том, чтобы мы могли задавать алгоритм сложения чисел в SomeAdd в независимости от того какие это числа, но присутствует ограничение в виде generic-ов с T.

Подробнее про все существующие `static virtual` интерфейсы для математики здесь:
[Generic math - .NET | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/standard/generics/math)

## Struct

Структуры - это те же классы, используют шаблон, похожий на шаблон классов.
Структуры предполагается использовать как шаблон для сырых данных, а не объектов, по факту структуры являются пометкой для компилятора, как и в случае с классами.

Инстансы структур - сырые данные, которые можно упаковывать (box) в объекты и распаковывать (unbox) обратно. Раньше я уже писал, что мы используем сырые данные в методах точно также как и объекты, тоже касается и полей. Во время компиляции вставляется нужный вызов, просто напоминаю об этом ещё раз, т.к в данной главе рассматривается во что превращается структура и какие ограничения накладывает компилятор, а то как работают объекты и сырые данные мы уже прекрасно знаем.

Пустой и типичный шаблон структуры выглядит примерно так:
```cs
// Empty C# struct
struct MyStruct;
struct MyStruct2 { public int MyField; }
// Converted to IL
.class private sequential ansi sealed beforefieldinit MyStruct
    extends [System.Runtime]System.ValueType
{
	// Only for empty struct:
	// 0 - auto, 1 - size in bytes (zero)
    .pack 0
    .size 1
}
.class private sequential ansi sealed beforefieldinit MyStruct2
    extends [System.Runtime]System.ValueType
{
    .field public int32 MyField;
}
```

Особенности шаблона структуры в C#:
- Инстансы этого шаблона маркируется для компилятора как сырые данные, а сам шаблон порождает сырые данные.
- По умолчанию всегда расширяем (`extends`, наследуемся) от System.ValueType.
- Схема с модификатором `sealed` (наследоваться от неё запрещено).
- Нет конструктора по умолчанию, в этом случае все поля инициализируются своими значениями по умолчанию (обычно 0).
- Для инициализации полей (через сахар в виде инициализации в полях) должен быть явно определён конструктор.
- Во все конструкторы вставляется инициализация полей.
- В конструкторах не создаётся вызова конструктора базовой схемы.
- По умолчанию выравнивание сырых данных стоит в режиме `sequential`, т.к предполагается совместимость с нативным кодом при маршалинге, а также чёткое неизменяемое выравнивание.
- Может иметь модификаторы: `partial, readonly, ref`.
- Не может иметь виртуальных статических методов.
- Не может иметь деструктор.

У структур без пустого конструктора или без вызова конструктора с параметрами вместо `newobj instance` (вызова конструктора) вызывается `initobj`, который инициализирует объект значениями по умолчанию без вызова конструктора.

`readonly` модификатор работает точно также, как и у классов, но для структур это более важный момент, т.к методы тоже будут `[IsReadOnly]`, что в итоге позволит JIT-у компилировать более эффективный код, копируя меньше значений.

`ref` модификатор добавляет к структуре атрибут `[IsByRefLike]` и даёт понять компилятору, что инстанс (сырые данные) данной структуры может находится только на стэке. А так даёт возможность определять `ref` поля, которые должны указывать на какие-то сырые данные на стэке. Т.е у нас структура будет хранить ссылку, а не значения.
На основе `ref struct` сделаны `ReadOnlySpan/Span`-ы которые позволяют безопасно оперировать с массивами данных на стэке.

## System.Enum

System.Enum является базовой схемой для перечислений (enum), содержит множество методов по работе с ними (по большей части форматирование).
В качестве базовой схемы System.Enum использует System.ValueType, поэтому перечисления являются сырыми данными. И мы также не можем наследоваться от System.Enum в C#, как и от System.ValueType.

Переопределяет методы из System.ValueType - ToString, Equals, CompareTo, GetHashCode.
По большей части эти методы свичатся по базовому типу заданному в перечислении, и уже на основании этого производится простое действие, что-то вроде обёртки.

Переопределённые методы из System.ValueType работают хорошо, а вот метод HasFlag, определённый в System.Enum, вызывает упаковку (`box`) в объект, да и в имплементации этого метода есть вызов GetType, как и в ToString, что тоже вызывает упаковку.
Поэтому будьте осторожны с этим, лучше определить свой Extension метод для проверки флагов побитово.

## Enum

Enum-ы (перечисления) - предоставляют удобную форму определения константных перечислений в виде keyword-ов, вместо чисел. Сами по себе Enum-ы очень похожи на структуру с одним полем и несколькими константами (статические `literal` поля), которые имеют кастомные названия и число (по умолчанию число задаётся из порядка в котором определены константы, инкрементируя предыдущее число на 1, либо используется число заданное вручную).

Enum-ы всегда имеют базовую схему (наследуются) в виде System.Enum, которая тоже является флагом, что это именно перечисление. Нужно понимать что схема System.Enum наследуется от System.ValueType, что делает перечисления сырыми данными.

Перечисление имеет одно поле, тип которого по умолчанию `int`, однако этот тип можно сменить на другой числовой используя синтаксис вида `enum MyEnum : byte { }`, использовать можно только эти типы: `byte, sbyte, short, ushort, int, uint, long, ulong`, хотя сам по себе System.Enum поддерживает ещё `float, double, nint, nuint, char, bool`.
Само поле имеет техническое название `value__` и имеет модификаторы `specialname rtspecialname`, что позволяет определить перечисление помимо `extends` от System.Enum.

Для перечислений, как и для чисел, могут выполнятся побитовые операции. Это удобно для флагов, когда мы совмещаем в одно число несколько битовых флагов. Для обозначения намерения и более красивого вывода (форматирования) перечислений в виде флагов используется атрибут `[Flags]`, его использование не обязательно, но желательно.

Шаблоны перечисления выглядят примерно так:
```cs
// Empty C# struct
enum MyEnum;
enum MyEnum2 : byte { ConstName1, ConstName2 }
enum MyEnum3 : byte { ConstName1 = 5, ConstName2 }
[Flags] enum MyEnum4 : byte { Read = 1, Write = 2, Execute = 4 }
// Converted to IL
.class private auto ansi sealed MyEnum
    extends [System.Runtime]System.Enum
{
    .field public specialname rtspecialname int32 value__
}

.class private auto ansi sealed MyEnum2
    extends [System.Runtime]System.Enum
{
    .field public specialname rtspecialname uint8 value__
    .field public static literal valuetype MyEnum2 ConstName1 = uint8(0)
    .field public static literal valuetype MyEnum2 ConstName2 = uint8(1)
}

.class private auto ansi sealed MyEnum3
    extends [System.Runtime]System.Enum
{
    .field public specialname rtspecialname uint8 value__
    .field public static literal valuetype MyEnum3 ConstName1 = uint8(5)
    .field public static literal valuetype MyEnum3 ConstName2 = uint8(6)
}
.class private auto ansi sealed MyEnum4
    extends [System.Runtime]System.Enum
{
    .custom instance void [System.Runtime]System.FlagsAttribute::.ctor() = (
        01 00 00 00
    )
    .field public specialname rtspecialname uint8 value__
    .field public static literal valuetype MyEnum4 Read = uint8(1)
    .field public static literal valuetype MyEnum4 Write = uint8(2)
    .field public static literal valuetype MyEnum4 Execute = uint8(4)
}
```

Особенности шаблона структуры в C#:
- Инстансы этого шаблона маркируется для компилятора как сырые данные, а сам шаблон порождает сырые данные.
- Всегда расширяем (`extends`, наследуемся) от System.Enum.
- Схема с модификатором `sealed` (наследоваться от неё запрещено).
- Конструктор, поля, методы запрещены, разрешены только имена с заданием числового значения.
- По умолчанию выравнивание сырых данных стоит в режиме `auto`.
- Не имеет никаких модификаторов, кроме доступа.
- Имеет одно поле `value__`, по умолчанию типа `int`.
- Можно менять базовый тип одного единственного поля.
- Можем добавлять константы в виде их имён и числовых значений.

Вот такие довольно-таки слабые возможности у перечислений.
При использовании их в коде, вставляются константы. А при использовании в виде переменной используются сырые данные, на самом деле просто число, тип которого мы можем задать.
Однако, многие механизмы можно взломать 😈, расшив наши возможности, подсунув свои схемы, правда тогда мы будем лишены удобной поддержки IDE и анализаторов.

Кстати, чем дальше идём, тем больше видим костылей и слабых мест от разработчиков платформы 😅

## Delegate

Делегаты представляют из себя обёртку над указателем к нативному методу (stub-у, который уже ведёт на скомпилированный JIT-ом метод, либо на первичную JIT компиляцию этого метода после которой заменяется адрес, что в итоге приводит к первому случаю).
Т.е делегат семантически представляет из себя метод, который мы можем вызвать. Грубо говоря это даёт нам возможность получить и использовать ссылку на метод.

Делегат всегда наследуется от System.MulticastDelegate, который в свою очередь наследуется от System.Delegate, а тот от System.Object. Поэтому делегаты - это объекты.
Следует отметить, что от System.MulticastDelegate нельзя наследоваться в своих классах, компилятор не даст.

Любой делегат разворачивается в класс, единственное отличие - разные сигнатуры методов вызова.
Вот шаблон с примером:
```cs
// C# delegate
delegate int MyDelegate();
// Converted to IL
.class private auto ansi sealed MyDelegate
    extends [System.Runtime]System.MulticastDelegate
{
    .method public hidebysig specialname rtspecialname 
        instance void .ctor (
            object 'object',
            native int 'method'
        ) runtime managed { }
    .method public hidebysig newslot virtual 
        instance int32 Invoke () runtime managed { }
    .method public hidebysig newslot virtual 
        instance class [System.Runtime]System.IAsyncResult BeginInvoke (
            class [System.Runtime]System.AsyncCallback callback,
            object 'object'
        ) runtime managed { }
    .method public hidebysig newslot virtual 
        instance int32 EndInvoke (
            class [System.Runtime]System.IAsyncResult result
        ) runtime managed { }
}
```

Особенности шаблона делегата в C#:
- Инстансы этого шаблона маркируется для компилятора как объект, а сам шаблон порождает объекты.
- Всегда расширяем (`extends`, наследуемся) от System.MulticastDelegate.
- По умолчанию выравнивание сырых данных стоит в режиме `auto`.
- Схема с модификатором `sealed` (наследоваться от неё запрещено).
- Можем задать только модификатор доступа для схемы.
- Мы можем задавать сигнатуру делегата, что в итоге изменит сигнатуру сгенерированных методов Invoke/BeginInvoke/EndInvoke, конструктор не меняется. Сама же имплементация этих методов находится в нативном коде, что нам и говорят модификаторы `runtime managed`.

Компилятор в местах использования делегатов вставляет шаблонный код с кэшированием в виде `nested` класса в классе, где мы создаём делегат. Это выглядит примерно так:

```cs
// C#
delegate int MyDelegate1();
delegate int MyDelegate2(int a);

class Program
{
    public static void Main()
    {
        MyDelegate1 m1 = MyMethod1;
        MyDelegate1 m2 = AnotherClass.MyMethod20;
        MyDelegate2 m3 = MyMethod50;
        
        m1(); m2(); m3(5);
    }
    public static int MyMethod1() => 0
    public static int MyMethod50(int a) => a;
}
class AnotherClass { public static int MyMethod20() => 2; }
// Converted to IL
.class private auto ansi beforefieldinit Program
    extends [System.Runtime]System.Object
{
	// Delegate cache class
    .class nested private auto ansi abstract sealed beforefieldinit '<>O'
        extends [System.Runtime]System.Object
    {
        .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (01 00 00 00)
        .field public static class MyDelegate1 '<0>__MyMethod1'
        .field public static class MyDelegate1 '<1>__MyMethod20'
        .field public static class MyDelegate2 '<2>__MyMethod50'
    }
    .method public hidebysig static 
        void Main () cil managed 
    {
        .maxstack 2
        .locals init (
            [0] class MyDelegate1 m1,
            [1] class MyDelegate1 m2
        )

        IL_0000: ldsfld class MyDelegate1 Program/'<>O'::'<0>__MyMethod1'
        IL_0005: dup
        // Jump, if we have cached instance
        IL_0006: brtrue.s IL_001b

		// Else create new instance and save it to cache
        IL_0008: pop
        IL_0009: ldnull
        IL_000a: ldftn int32 Program::MyMethod1()
        IL_0010: newobj instance void MyDelegate1::.ctor(object, native int)
        IL_0015: dup
        IL_0016: stsfld class MyDelegate1 Program/'<>O'::'<0>__MyMethod1'

        IL_001b: stloc.0
        IL_001c: ldsfld class MyDelegate1 Program/'<>O'::'<1>__MyMethod20'
        IL_0021: dup
        IL_0022: brtrue.s IL_0037

        IL_0024: pop
        IL_0025: ldnull
        IL_0026: ldftn int32 AnotherClass::MyMethod20()
        IL_002c: newobj instance void MyDelegate1::.ctor(object, native int)
        IL_0031: dup
        IL_0032: stsfld class MyDelegate1 Program/'<>O'::'<1>__MyMethod20'

        IL_0037: stloc.1
        IL_0038: ldsfld class MyDelegate2 Program/'<>O'::'<2>__MyMethod50'
        IL_003d: dup
        IL_003e: brtrue.s IL_0053

        IL_0040: pop
        IL_0041: ldnull
        IL_0042: ldftn int32 Program::MyMethod50(int32)
        IL_0048: newobj instance void MyDelegate2::.ctor(object, native int)
        IL_004d: dup
        IL_004e: stsfld class MyDelegate2 Program/'<>O'::'<2>__MyMethod50'

        IL_0053: ldloc.0
        IL_0054: callvirt instance int32 MyDelegate1::Invoke()
        IL_0059: pop
        IL_005a: ldloc.1
        IL_005b: callvirt instance int32 MyDelegate1::Invoke()
        IL_0060: pop
        IL_0061: ldc.i4.5
        IL_0062: callvirt instance int32 MyDelegate2::Invoke(int32)
        IL_0067: pop
        IL_0068: ret
    }
    .method public hidebysig static 
        int32 MyMethod1 () cil managed 
    {
        .maxstack 8
        IL_0000: ldc.i4.0
        IL_0001: ret
    }
    .method public hidebysig static 
        int32 MyMethod50 (
            int32 a
        ) cil managed 
    {
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: ret
    }
	...
}
.class private auto ansi beforefieldinit AnotherClass
    extends [System.Runtime]System.Object
{
    .method public hidebysig static 
        int32 MyMethod20 () cil managed 
    {
        .maxstack 8
        IL_0000: ldc.i4.2
        IL_0001: ret
    }
    ...
}
```

Можно заметить, что кэш находится именно в месте создания, а не в месте нахождения целевого метода (делегат метода из AnotherClass кэшируется в Program.'<>O').
Также можем заметить, что в вызов конструктора делегата передаётся `object` и `nint`(`IntPtr`), в первое у нас передаётся `null`, т.к методы статические, а во второе передаётся указатель на метод с помощью инструкции `ldftn`, что довольно-таки интересно, т.к в C# нет простой возможности получить указатель на метод, кроме как через делегат, в итоге делаем вывод что используя Unsafe/Expression/IL мы можем вставить нужные нам инструкции и получить то, что нам не дано стандартными средствами C#, можно даже сделать свои делегаты.

Операции `+=, -=` (добавление/удаление делегата из списка вызовов в делегате) заменяется на System.Delegate.Combine и System.Delegate.Remove соответственно, которые создают новый объект, но уже с изменённым списком вызовов. В имплементации лежит довольно-таки длинный и замороченный код, учитывающий нахождение в списке: методов, нативных методов, делегатов, мультикаст делегатов.

## Record

Record-ы представляют из себя синтаксический сахар, более короткую запись для классов/структур. Самая главная их особенность - это автоматическая имлементация `IEquatable<T>` и переопределение и создание методов: `ToString, PrintMembers, operator !=/==, GetHashCode, Equals/Equals<T>, Deconstruct`, а также автоматическое определение свойств и конструктора.

Существуют 3 типа record-ов:
1. `record class` - иммутабельный класс (readonly поля). Сравнение объектов происходит по ссылке -> типу -> значениям, что довольно-таки важно, сравнение происходит по значению (сырым данным). Хэшкод = тип + значения.
2. `record struct` - read/write структура. Сравнение происходит по типу -> значениям. Хэшкод = значения.
3. `readonly record struct` - иммутабельная структура (readonly поля и `[IsReadOnly]` атрибут на структуре). Сравнение происходит по типу -> значениям. Хэшкод = значения.

По умолчанию `record` - это `record class`, поэтому модификатор `class` можно опустить, либо использовать для явности.

Наследование поддерживается только в `record class` и только от `record class`. Именно поэтому сигнатура некоторых методов отличается у `record class` и `record struct`, добавляя модификатор `virtual` и повышая доступ до `protected`, а также в структурах отсутствует свойство `EqualityContract`.

В данном случае шаблон разворачивается не в IL, а в C# код, т.к это сахар.

Пример пустого шаблона:

```cs
// Source
record MyRecordClass1;
// After compilation
[NullableContext(1), Nullable(0)]
class MyRecordClass1 : IEquatable<MyRecordClass1>
{
    [CompilerGenerated]
    protected virtual Type EqualityContract
    {
        [CompilerGenerated] get => typeof(MyRecordClass1);
    }
    [CompilerGenerated]
    public override string ToString()
    {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append("MyRecordClass1");
        stringBuilder.Append(" { ");
        if (PrintMembers(stringBuilder))
            stringBuilder.Append(' ');
        stringBuilder.Append('}');
        return stringBuilder.ToString();
    }
    [CompilerGenerated]
    protected virtual bool PrintMembers(StringBuilder builder) => false;
    [NullableContext(2), CompilerGenerated]
    public static bool operator !=(MyRecordClass1 left, MyRecordClass1 right) =>
	    !(left == right)
    [NullableContext(2), CompilerGenerated]
    public static bool operator ==(MyRecordClass1 left, MyRecordClass1 right)
    {
        if ((object)left != right)
        {
            if ((object)left != null)
                return left.Equals(right);
            return false;
        }
        return true;
    }
    [CompilerGenerated]
    public override int GetHashCode() =>
        EqualityComparer<Type>.Default.GetHashCode(EqualityContract);
    [NullableContext(2), CompilerGenerated]
    public override bool Equals(object obj) => Equals(obj as MyRecordClass1)
    [NullableContext(2), CompilerGenerated]
    public virtual bool Equals(MyRecordClass1 other)
    {
        if ((object)this != other)
        {
            if ((object)other != null)
                return EqualityContract == other.EqualityContract;
            return false;
        }
        return true;
    }
    [CompilerGenerated]
    public virtual MyRecordClass1 <Clone>$() => new MyRecordClass1(this);
    [CompilerGenerated]
    protected MyRecordClass1(MyRecordClass1 original) {}
    public MyRecordClass1() {}
}
```

Пример типичного шаблона (опустил атрибуты и то, что не поменялось):

```cs
// Source
record class MyRecordClass2(int Value);
// After compilation
class MyRecordClass2 : IEquatable<MyRecordClass2>
{
    private readonly int <Value>k__BackingField;
    public int Value
    {
        get => <Value>k__BackingField;
        init => <Value>k__BackingField = value;
    }
    public MyRecordClass2(int Value)
    {
        <Value>k__BackingField = Value;
        base..ctor();
    }
    protected virtual bool PrintMembers(StringBuilder builder)
    {
        RuntimeHelpers.EnsureSufficientExecutionStack();
        builder.Append("Value = ");
        builder.Append(Value.ToString());
        return true;
    }
    public override int GetHashCode()
    {
        return EqualityComparer<Type>.Default.GetHashCode(EqualityContract) * -1521134295 + EqualityComparer<int>.Default.GetHashCode(<Value>k__BackingField);
    }
    public virtual bool Equals(MyRecordClass2 other)
    {
        if ((object)this != other)
        {
            if ((object)other != null && EqualityContract == other.EqualityContract)
            {
                return EqualityComparer<int>.Default.Equals(<Value>k__BackingField, other.<Value>k__BackingField);
            }
            return false;
        }
        return true;
    }
    protected MyRecordClass2(MyRecordClass2 original)
    {
        <Value>k__BackingField = original.<Value>k__BackingField;
    }
    public void Deconstruct(out int Value)
    {
        Value = this.Value;
    }
}
```

Вот что поменяется, если мы сделаем `readonly record struct`/`record struct`:

```cs
// Source
readonly record struct MyReadOnlyRecordStruct(int Value);
// After compilation
[IsReadOnly]
struct MyReadOnlyRecordStruct : IEquatable<MyReadOnlyRecordStruct>
{
	// EqualityContract property removed
	// virtual modifier removed, access modifier updated: protected -> private
    private bool PrintMembers(StringBuilder builder)
    {
	    // RuntimeHelpers.EnsureSufficientExecutionStack() removed
        builder.Append("Value = ");
        builder.Append(Value.ToString());
        return true;
    }

    [CompilerGenerated]
    public static bool operator ==(MyReadOnlyRecordStruct left, MyReadOnlyRecordStruct right)
    {
	    // Reference and null checks removed
        return left.Equals(right);
    }

    [CompilerGenerated]
    public override int GetHashCode()
    {
	    // EqualityContract (type) hashcode removed
        return EqualityComparer<int>.Default.GetHashCode(<Value>k__BackingField);
    }

    [CompilerGenerated]
    public override bool Equals(object obj)
    {
        if (obj is MyReadOnlyRecordStruct) // Type check added
        {
            return Equals((MyReadOnlyRecordStruct)obj); // Boxing
        }
        return false;
    }
	// virtual modifier removed
    public bool Equals(MyReadOnlyRecordStruct other)
    {
	    // Reference, type and null checks removed
        return EqualityComparer<int>.Default.Equals(<Value>k__BackingField, other.<Value>k__BackingField);
    }
    // Constructor TypeName(TypeName original) removed
}
```

Особенности шаблона record-ов в C#:
- Может иметь модификаторы: `class, struct, readonly struct, abstract class, sealed class, partial`.
- Не забываем, что в `record`-ах можно определять методы, свойства, поля, всё как у обычных классов/структур, только с своими особенностями.
- Наследование рекордов накладывает некоторые костыльные ограничения компилятора и условности. В сложных случаях лучше перейти на явную имплементацию, вместо рекордов, рекорды нужны для небольших классов, чтобы писать меньше бойлерплейта.

## System.Array

Массив представляет из себя некое хранилище фиксированного размера для сырых данных. 
Сам по себе System.Array наследуется от System.Object, что делает любой массив объектом.
Сами сырые данные хранятся прямиком в объекте массива сразу же после Length и Padding-а (только для x64). Следовательно все элементы массива, как и сам объект массива хранятся в куче.

System.Array имплементирует интерфейсы `ICloneable, IList, IStructuralComparable, IStructuralEquatable`, а также хитрым способом для `T[]` (одномерные SZ) массивов имплементирует `IList<T>` и `IReadOnlyList<T>`.

Структура RawArrayData выглядит примерно так:

```cs
internal sealed class RawArrayData
{
	public uint Length;
#if TARGET_64BIT
	public uint Padding;
#endif
	public byte Data;
}
```

`byte Data` выступает в качестве метки для начала перечисления сырых данных. А `Length` используется для получения длинны массива.

Удивительно что `Padding` нужен только для грамотного выравнивания памяти в x64 системах, дело в том, что выравнивание в такой системе происходит по 8 байт, т.к `Length` 4 байта, мы добавляем к ним пустой `Padding`, тоже 4 байта, в итоге соблюдая выравнивание. Именно для этого оно и нужно, чтобы заполнить пробел. А элементы массива уже выравниваются отдельно от этого всего, поэтому такой костыль - это норма.

Ещё интересный момент - тип элементов массива, как и их размер в байтах хранятся в `MethodTable` объекта. Тоже самое и для строк, более того у строк похожая структура с RawArrayData, первым элементом будет длинна строки. Поэтому можно сказать, что строки - это своеобразные массивы `char`.

Существуют одномерные массивы (single-dimensional) и многомерные массивы (multidimensional). Преимущество одномерных массивов в их простоте и скорости, однако это работает только с теми, у кого начальный индекс - 0, их ещё называют SZ (single-dimensional, zero-based) массивы или вектора. Для получения доступа к элементам, записи, получения длинны используются специальные IL инструкции для массивов (`newarr, ldelem, ldelema, ldelem.ref, ldlen, stelem, stelem.ref`), вместо методов, как у многомерных или у не нулевых, что довольно-таки сильно влияет на производительность, а также у не нулевых или многомерных массивов постоянно вычисляется смещение. Поэтому используйте многомерные массивы с осторожностью и делайте бенчмарки.

Массивы с не нулевой нижней границей можно создать с помощью `Array.CreateInstance`, возможность есть, но смысла нет.

Также существуют jagged (неровные/нерегулярные) массивы, на самом деле это те же одномерные массивы, просто хранят ссылки на другие массивы, т.е просто трюк, который ничего не меняет, с тем же успехом можно хранить строки, объекты, листы.
Но стоит, например, понимать, что реализация многомерного пространства с помощью одного одномерного массива будет быстрее, чем реализация через jagged массивы, т.к у jagged массивов не прямой доступ к элементам (нужно несколько раз обратиться к памяти, чтобы получить нужный массив и элемент), что также плохо сыграет с кэшем процессора.

Обычно при каждом обращении к элементу массива проверяются границы, не выходите ли вы за них, чтобы выдать `IndexOutOfRangeException`, однако зачастую нет смысла каждый раз проверять это, например, в циклах будет всего одна проверка на выход за границы, перед началом цикла. Чтобы избежать таких проверок можно, конечно, использовать `unsafe` код.

#### Инициализаторы массива

Интересно что инициализаторы массива, будь то `{ 1, 2, 3 }` или `[1, 2, 3]` переносятся в метаданные в виде массив байт, которые хранятся в `'<PrivateImplementationDetails>'` в подобном виде:

```cs
.class private auto ansi sealed '<PrivateImplementationDetails>'
    extends [System.Runtime]System.Object
{   
    .class nested assembly explicit ansi sealed '__StaticArrayInitTypeSize=12'
        extends [System.Runtime]System.ValueType
    {
        .pack 1
        .size 12
    }
    
    .field assembly static initonly valuetype '<PrivateImplementationDetails>'/'__StaticArrayInitTypeSize=12' '4636993D3E1DA4E9D6B8F87B79E8F7C6D018580D52661950EABC3845C5897A4D' at I_000027B8
    
    .data cil I_000027B8 = bytearray (
        01 00 00 00 02 00 00 00 03 00 00 00 // 1 2 3
    )
}
```

Где `'<PrivateImplementationDetails>'/'__StaticArrayInitTypeSize=12'` - тип/схема, которая определена в виде `nested` схемы и является сырыми данными (похоже на шаблон структуры), а `'4636993D3E1DA4E9D6B8F87B79E8F7C6D018580D52661950EABC3845C5897A4D'` - название статического поля с пометкой `at I_000027B8` (адреса на метаданные).

Большинство магии происходит во время использования сия чуда:

```cs

ldc.i4.3
newarr [System.Runtime]System.Int32
dup

// Load field token (runtime field handle)
ldtoken field valuetype '<PrivateImplementationDetails>'/'__StaticArrayInitTypeSize=12' '<PrivateImplementationDetails>'::'4636993D3E1DA4E9D6B8F87B79E8F7C6D018580D52661950EABC3845C5897A4D'

// Initialize (fill) array with data from runtime field handle
call void [System.Runtime]System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(class [System.Runtime]System.Array, valuetype [System.Runtime]System.RuntimeFieldHandle)

pop
ret
```

Теперь мы понимаем, что это просто трюк, который позволяет эффективно заполнить массив константными данными, вместо того чтобы в runtime заполнять каждый элемент по очереди с помощью индекса.

Однако такой эффективный способ используется только для сырых данных! Любые объекты, в виде `string`, `object`, `myClassObject` будут заполняться в массив по очереди с помощью индекса, например `["1", "2", "3"]` преобразуется в вид:

```cs
ldc.i4.3 // Length
newarr [System.Runtime]System.String
dup

ldc.i4.0 // Index
ldstr "1" // Value
stelem.ref
dup

ldc.i4.1 // Index
ldstr "2" // Value
stelem.ref
dup

ldc.i4.2 // Index
ldstr "3" // Value
stelem.ref
```

Это происходит потому что мы не можем хранить ссылки в виде констант compile time, т.к адреса в памяти не являются константами, да и объекты требуют вызова конструктора.
Ещё раз закрепляем, что массивы лучше всего работают именно с сырыми данными, а не объектами.

#### Приведение типов в массивах

Работает почти также, как и приведение типов у объектов, за исключением того, что отсутствует упаковка/распаковка, т.к приведение типов в массивах поддерживается только объектами, мы не можем приводить типы сырых данных.

А ещё при приведении действительно копируется ссылка на массив и используется другая "переменная", в отличие от приведения в объектах. Это требуется для поддержки typecheck-ов и ковариантности массивов в runtim-е, по тем же причинам ссылка копируется и для ковариантности в интерфейсах.

Посмотрим это на примере:

```cs
string[] s = { "1", "2", "3" };
object[] o = s;
Console.WriteLine(o[0]);
// IL Code
.locals init (
	[0] object[]
)

ldc.i4.3
newarr [System.Runtime]System.String
dup

ldc.i4.0
ldstr "1"
stelem.ref

dup
ldc.i4.1
ldstr "2"
stelem.ref

dup
ldc.i4.2
ldstr "3"
stelem.ref

stloc.0 // Copy original ref to `[0] object[]` local
ldloc.0 // Load local `[0] object[]` (reference to original array)

ldc.i4.0
ldelem.ref
call void [System.Console]System.Console::WriteLine(object)
ret
```

Однако метод `Array.Copy` поддерживает упаковку/распаковку, что позволяет нам упаковывать массив сырых данных в объекты или наоборот, а также поддерживает widening (расширение, грубо говоря конвертация чисел, например, `int` в `long`), но, конечно, это всё не бесплатно. Т.к он по факту не приводит типы, а конвертирует массив одного типа в массив другого типа.

Условия для медленного копирования:
- Unboxing (объект -> сырые данные).
- Boxing (сырые данные -> объект).
- Расширение примитив (Primitive Widen, например `int` в `long`).
- Явный casting с неизвестным результатом (например, конвертация `object[]` в `IDisposable`, не факт что все объекты имплементируют этот интерфейс).

При медленном копировании, каждый элемент конвертируется и копируется по очереди в цикле, что довольно-таки медленно, в отличии от быстрого копирования, где копируется целый регион памяти, например, с помощью `Memmove`.

Есть способ избежать медленного копирования (мы получим ArrayTypeMismatchException, если будет выполнено одно из условий медленного копирования) - использовать `Array.ConstrainedCopy`.

Помимо методов копирования, у `Array` есть много полезных статических методов: `AsReadOnly, BinarySearch, Clear, ConstrainedCopy, ConvertAll, Copy, CreateInstance, Empty, Exists, Fill, Find, FindAll, FindIndex, FindLast, FindLastIndex, ForEach, IndexOf, LastIndexOf, Resize, Reverse, Sort, TrueForAll`.

Отмечу полезный метод `Empty<T>`, который возвращает кэшированную ссылку на пустой массив с определённым типом элементов, очень полезно, когда нужно вернуть пустой массив, дабы не аллоцировать лишний раз память.

Метод `Sort` использует `Introspective` сортировку, совмещающую в себе `Insertion` и `Heap` сортировку, в зависимости от условий. Интересный и эффективный подход.

## System.ArraySegment

`ArraySegment<T>` представляет из себя `readonly struct`, который содержит ссылку на массив `T[] _array`, `_offset` и `_count`. Даёт возможность взять срез/сегмент/слайс элементов из массива без копирования массива и аллокаций в куче (аллоцируется только сырые данные в виде `ArraySegment`-а, в большинстве случаев на стэке, если не является частью объекта).
Реализует интерфейсы `IList<T>, IReadOnlyList<T>`.

Применяется только для векторных массивов (SZ - Single dimensional Zero-based).

Удобно применять для разделения одного массива на части без копирования, например если вам нужно поделить массив на несколько потоков/задач.

Имеет статическое свойство `Empty` в котором кэшируется `ArraySegment<T>` с массивом `T[0]`, при первом обращении к типу `ArraySegment<T>`.

## System.Span

`Span<T>` представляет из себя `readonly ref struct`, который содержит `readonly ref T _reference` и `readonly int _length` поля. На самом деле это очень простая структура (span-ы это тоже сырые данные), куда проще массива. Она предоставляет нам возможность безопасного взаимодействия с любой памятью (внутри имплементировано на `unsafe`, но баги ложатся на плечи `dotnet`, поэтому это безопасно).

`_reference` представляет из себя адрес (`ref`) в памяти на первый элемент какого-нибудь массива, но не обязательно это должен быть массив, просто контракт этой структуры предполагает использование с массивами данных фиксированной длинны, но никто не запрещает, например, читать/записывать этим спаном сырые данные любого объекта в виде массива байт, если нам нужно сделать сериализатор.
Поэтому Span-ы довольно-таки удобны, в отличие от использования указателей.

Напомню, что `ref struct`-ы нельзя хранить в куче и использовать в качестве generic параметра. Однако в C#11 добавили возможность использования `ref struct`-ов в generic параметрах с помощью ограничения `: allows ref struct`, что позволяет принимать параметр в виде типа структуры, класса или `ref struct`, накладывая ограничения `ref struct`-ов на метод/класс.

Существует также версия `System.ReadOnlySpan<T>`, но она ничем не отличается, кроме как отсутствием возможности записи, а также встроенной возможностью обернуть строки (`string`).
Они имеют одинаковый memory layout, поэтому можно привести readonly версию в обычный спан с помощью `Unsafe.As` метода.

Помимо чтения памяти из кучи, Span-ы могут читать память из стэка (собственно ничего не меняется кроме региона памяти адреса `_reference`), а это в свою очередь позволяет нам использовать `stackalloc`, который аллоцирует память фиксированного размера в стэке и возвращает указатель на первый элемент в памяти, который используется для инициализации Span-а. Это даёт нам возможность безопасно использовать память на стэке (ограниченная 1MB для x32, 4MB для x64), не аллоцируя память в куче. Это позволяет ускорять некоторые алгоритмы во много раз!

Такая память на стэке очищается автоматически сразу после выхода из метода. Аллоцировать на стэке мы можем только сырые данные, интересно что в Span-ах мы пока не можем использовать в качестве параметра `T` другой Span, но никто не мешает нам скопировать код Span-а и добавить `T : allows ref struct`, но в то же время это ограничит использование типов объектов в качестве `T`, например `string`.

Примеры использования Span-а:

```cs
class MyClass { public int A = 5, B = 10; }
struct MyStruct { public long Foo; }
class Program
{
	[SkipLocalsInit]
    public unsafe static void Main()
    {
        var myClassObject = new MyClass();
        void* methodTablePtr = (void*)*(nint*)Unsafe.AsPointer(ref myClassObject);
        void* rawDataPtr = Unsafe.Add<nint>(methodTablePtr, 1); // Offset 1 times by sizeof(nint), x64 = +8 bytes, x32 = +4 bytes. We'll get ptr to first value
	    // Create span with start ptr and length
        Span<int> spanFromObject = new Span<int>(rawDataPtr, 2);
        Console.WriteLine(spanFromObject[0]); // 5
        Console.WriteLine(spanFromObject[1]); // 10
        
        spanFromObject[0] *= 5;
        spanFromObject[1] *= 5;
        Console.WriteLine(myClassObject.A); // 25
        Console.WriteLine(myClassObject.B); // 50
        
        Span<int> spanFromStack1 = stackalloc int[4];
        Span<MyStruct> spanFromStack2 = stackalloc MyStruct[4];
        
        Console.WriteLine(spanFromStack1[0]); // -857742488
        Console.WriteLine(spanFromStack2[0].Foo); // 2113503572384
    }
}
.method public hidebysig static void Main () cil managed 
{
	.custom instance void [System.Runtime]System.Runtime.CompilerServices.SkipLocalsInitAttribute::.ctor() = (01 00 00 00)
	.maxstack 3
	.locals (
		[0] class MyClass myClassObject,
		[1] void* methodTablePtr,
		[2] void* rawDataPtr,
		[3] valuetype [System.Runtime]System.Span`1<int32> spanFromObject,
		[4] valuetype [System.Runtime]System.Span`1<int32> spanFromStack1,
		[5] valuetype [System.Runtime]System.Span`1<valuetype MyStruct> spanFromStack2
	)
	// var myClassObject = new MyClass();
	newobj instance void MyClass::.ctor()
	stloc.0
	
	// void* methodTablePtr = (void*)*(nint*)Unsafe.AsPointer(ref myClassObject);
	ldloca.s 0
	call void* [System.Runtime]System.Runtime.CompilerServices.Unsafe::AsPointer<class MyClass>(!!0&)
	ldind.i
	stloc.1
	
	// void* rawDataPtr = Unsafe.Add<nint>(methodTablePtr, 1);
	ldloc.1
	ldc.i4.1
	call void* [System.Runtime]System.Runtime.CompilerServices.Unsafe::Add<native int>(void*, int32)
	stloc.2
	
	// Span<int> spanFromObject = new Span<int>(rawDataPtr, 2);
	ldloca.s 3
	ldloc.2
	ldc.i4.2
	call instance void valuetype [System.Runtime]System.Span`1<int32>::.ctor(void*, int32)
	
	// Console.WriteLine(spanFromObject[0]) // 5
	ldloca.s 3
	ldc.i4.0
	call instance !0& valuetype [System.Runtime]System.Span`1<int32>::get_Item(int32)
	ldind.i4
	call void [System.Console]System.Console::WriteLine(int32)
	
	// Console.WriteLine(spanFromObject[1]) // 10
	ldloca.s 3
	ldc.i4.1
	call instance !0& valuetype [System.Runtime]System.Span`1<int32>::get_Item(int32)
	ldind.i4
	call void [System.Console]System.Console::WriteLine(int32)
	
	// spanFromObject[0] *= 5;
	ldloca.s 3
	ldc.i4.0
	call instance !0& valuetype [System.Runtime]System.Span`1<int32>::get_Item(int32)
	dup
	ldind.i4
	ldc.i4.5
	mul
	stind.i4
	
	// spanFromObject[1] *= 5;
	ldloca.s 3
	ldc.i4.1
	call instance !0& valuetype [System.Runtime]System.Span`1<int32>::get_Item(int32)
	dup
	ldind.i4
	ldc.i4.5
	mul
	stind.i4
	
	// Console.WriteLine(myClassObject.A); // 25
	ldloc.0
	ldfld int32 MyClass::A
	call void [System.Console]System.Console::WriteLine(int32)
	
	// Console.WriteLine(myClassObject.B); // 50
	ldloc.0
	ldfld int32 MyClass::B
	call void [System.Console]System.Console::WriteLine(int32)
	
	// Span<int> spanFromStack1 = stackalloc int[4];
	ldc.i4.s 16
	conv.u
	localloc
	ldc.i4.4
	newobj instance void valuetype [System.Runtime]System.Span`1<int32>::.ctor(void*, int32)
	stloc.s 4
	
	// Span<MyStruct> spanFromStack2 = stackalloc MyStruct[4];
	ldc.i4.4
	conv.u
	sizeof MyStruct
	mul.ovf.un
	localloc
	ldc.i4.4
	newobj instance void valuetype [System.Runtime]System.Span`1<valuetype MyStruct>::.ctor(void*, int32)
	stloc.s 5
	
	// Console.WriteLine(spanFromStack1[0]); // -857742488
	ldloca.s 4
	ldc.i4.0
	call instance !0& valuetype [System.Runtime]System.Span`1<int32>::get_Item(int32)
	ldind.i4
	call void [System.Console]System.Console::WriteLine(int32)
	
	// Console.WriteLine(spanFromStack2[0].Foo); // 2113503572384
	ldloca.s 5
	ldc.i4.0
	call instance !0& valuetype [System.Runtime]System.Span`1<valuetype MyStruct>::get_Item(int32)
	ldfld int64 MyStruct::Foo
	call void [System.Console]System.Console::WriteLine(int64)
	ret
}
```

Напоминаю, что мы получили `-857742488` и `2113503572384` в конце потому что мы выключили инициализацию для сырых данных с помощью атрибута `[SkipLocalsInit]`, тут хороший usecase, т.к зачастую нам не нужно инициализировать аллоцированную в стэке память нулями. В итоге с помощью этого атрибута мы избавляемся от лишней инициализации и немного повышаем производительность. Мало кто знает о таких трюках, мотайте на ус.

Span-ы можно использовать не только для использования памяти стэка, но и для контрактов. Дело в том, что мы можем создавать контракты основываясь на Span-ах, не задумываясь о том что мы используем и как. Т.е пользователь контракта может положить туда Span, который ссылается на стэк, а может положить Span, который ссылается на память из кучи. Тем самым мы оставляем манёвр для оптимизации и выбор структуры данных для пользователей, делая контракт более гибким.

Рекомендую использовать Span-ы, особенно если работаете над низкоуровневыми библиотеками.

У Span-ов есть много интересных методов, например, `Slice` ничего не аллоцирует, кроме сырых данных на стэке в виде ещё одного Span-а, у которого просто `_reference` указывает на смещённый `offset`, а `length` на количество элементов которые мы указали для слайса. Т.е мы просто создаём другую "читалку памяти" с смещением, вместо того чтобы копировать куски данных и создавать объекты как это сделано в массивах.

## System.Memory

`Memory<T>` представляет из себя `readonly struct`, который содержит `object? _object`, `_index` и `_length`  поля. Это просто слайс памяти в виде последовательного доступа к элементам.
Имплементирует интерфейс `IEquatable<Memory<T>>`.

Практически тоже самое, что и `Span<T>`, однако это не `ref struct`, соответственно может храниться в объектах (можно упаковывать сырые данные и ссылаться на упакованный объект), т.е может храниться на куче, в отличие от спанов, поддерживает `await` и `yield`.

Однако может использоваться только со строками (`Memory<char>`, принимающий `string`), массивами (`T[]`) и `MemoryManager`-ом (нативная область памяти).

Имеет свойство `Span`, которое возвращает (создаёт) спан для текущего региона памяти.
Статическое свойство `Empty` ничего не кэширует, просто возвращает `default` каждый раз.

Также есть `ReadOnlyMemory<T>`, которое просто не имеет методов записи и используется только для чтения. Но можно преобразовать в `Memory<T>` с помощью `Unsafe.As`, т.к они имеют одинаковый memory layout.

Имеет методы `Slice`, для слайсинга, всё как у спанов и сегментов.

`unsafe` метод `Pin` используется для фиксации памяти в куче, чтобы [[GC]] не трогал и не двигал этот регион, меняя адрес указателя у объекта. Возвращает `MemoryHandle`, который позволяет сделать `unpin` этого региона. Фиксация памяти нужна для того, чтобы не менять адрес указателя, например, если мы хотим передать его в неуправляемый код. К примеру, если нам нужно передать массив байт, то мы передаём указатель на первый элемент этого массива, а сам массив остаётся неподвижным в памяти, пока мы его не разлочим.
Пиннить можно только blittable данные (примитивы, структуры содержащие только примитивы).

## Unsafe
*System.Runtime.CompilerServices.Unsafe*
*Это не про `unsafe` контекст компиляции, а про класс с полезными методами*

Предоставляет обобщённые низкоуровневые методы для работы с указателями и памятью. Позволяет использовать `unsafe` трюки безопасно (без необходимости использовать `unsafe` контекст). Хотя не все методы там такие, а только те, которые используют указатели в сигнатуре метода, например, `void*, nint*, anyType*`.

`Unsafe` Довольно-таки удобная вещь, когда нужно провернуть какие-то лайфхаки с памятью, например, замапить структуру-читалку на регион памяти объекта.

Покажу интересные примеры чтения сырых данных у любого объекта в куче без применения `unsafe` контекста и с ним.

```cs
class RawData { public byte Data; } // Only for get first field in any obj
class MyClass { public int A = 0, B = 10; }

public static void Main()
{
	var @object = new MyClass();
	
	var rawDataSpan = GetRawDataReaderSafeManual(@object);
	DoSomeWork(rawDataSpan, @object); // 0 changed to 1, 10 changed to 11
	
	// Universal methods
	
	rawDataSpan = GetRawDataReaderSafeUniversal<MyClass, int>(@object, 2);
	DoSomeWork(rawDataSpan, @object); // 1 changed to 2, 11 changed to 12
	
	rawDataSpan = GetRawDataReaderUnsafe1<MyClass, int>(@object, 2);
	DoSomeWork(rawDataSpan, @object); // 2 changed to 3, 12 changed to 13
	
	rawDataSpan = GetRawDataReaderUnsafe2<MyClass, int>(@object, 2);
	DoSomeWork(rawDataSpan, @object); // 3 changed to 4, 13 changed to 14
}
public static void DoSomeWork(Span<int> rawData, MyClass @object)
{
	Console.WriteLine(rawData[0]++ + " changed to " + @object.A);
	Console.WriteLine(rawData[1]++ + " changed to " + @object.B);
	Console.WriteLine();
}

public static Span<int> GetRawDataReaderSafeManual(MyClass obj)
{
	ref var rawDataRef = ref obj.A;
		
	return MemoryMarshal.CreateSpan(ref rawDataRef, 2);
}
public static Span<TRead> GetRawDataReaderSafeUniversal<TFrom, TRead>(TFrom obj, int length)
{
	// We need RawData to get first value ref in any object (universal method)
	ref var rawData = ref Unsafe.As<TFrom, RawData>(ref obj);
	ref var rawDataRef = ref Unsafe.As<byte, TRead>(ref rawData.Data);
		
	return MemoryMarshal.CreateSpan(ref rawDataRef, length);
}
public unsafe static Span<TRead> GetRawDataReaderUnsafe1<TFrom, TRead>(TFrom obj, int length)
{
	var ptrToMethodTablePtr = Unsafe.AsPointer(ref obj);
	var methodTableAddress = Unsafe.Read<nint>(ptrToMethodTablePtr);
	
	var rawDataAddress = methodTableAddress + IntPtr.Size;
	var rawDataPtr = rawDataAddress.ToPointer();
	
	return new Span<TRead>(rawDataPtr, length);
}
public unsafe static Span<TRead> GetRawDataReaderUnsafe2<TFrom, TRead>(TFrom obj, int length)
{
	void* methodTablePtr = (void*)*(nint*)Unsafe.AsPointer(ref obj);
	var rawDataPtr = Unsafe.Add<nint>(methodTablePtr, 1); // methodTablePtr + IntPtr.Size
	
	return new Span<TRead>(rawDataPtr, length);
}
```

Два последних метода использовали `unsafe` контекст, а первые два - нет. Второй универсальный метод использует лайфхак с реинтерпретацией любого типа в RawData (в CLR реинтерпретация выглядит как generic метод с нужной сигнутурой содержащий 2 инструкции - `ldarg.0, ret`), что позволяет нам читать наш объект так, как будто бы это RawData, что в итоге даёт нам универсальность в получении `ref`-а на первое поле. А `ref` по своей сути это безопасный (managed) указатель (ссылка).

Рекомендую использовать именно второй метод, за его простоту, универсальность и безопасность.

## Namespace

CLR ничего не знает про пространство имён, в нём всегда используется полное имя типа.
Компилятор в процессе заменяет короткие имена на длинные, позволяя писать меньше кода.

## Unsafe

## GC

## Threads

## Async





//
// The generational GC requires that every object be at least 12 bytes
// in size.


// Access the ObjHeader which is at a negative offset on the object (because of
// cache lines)


Я так узнал, что любые объекты в .net должны иметь размер минимум 12 байт, т.к это требование инкрементального сборщика мусора

И ещё что SyncBlockIndex находится в -InPtr смещении для оптимизации кэш линий


Если в MT нет ComponentSize, то ComponentSize будет равен dwflags (например у Object dwflags 512, поэтому и ComponentSize = 512).
ComponentSize есть у строк и массивов, этот параметр указывает размер (в байтах) элемента, т.е для строки - это char, значит ComponentSize = 2 байта.

Чанки vtable по 8 слотов, но изначально первый чанк 4 (т.к у System.Object 4 виртуальных метода).

Виртуальные методы в структурах имеют BoxedEntryPoint method desc в их vtable.

BaseSize - размер всего объекта. Обычно 24, у строк 22. BaseSize может быть минимум 12 байт. BaseSize складывается их header-а объекта (SyncIndex, MethodTablePtr = всё это 16 байт) и сырых данных (которые могут по-разному упаковываться). Естественно это всё зависит от разрядности, все примеры выше - на x64, на x32 размер указателей будет меньше и местами будет отсутствовать padding.
Хоть у строк размер объекта всегда 22, они имеют больший размер, всё дело в том, что строка имеет 2 поля `length` и `firstChar`, всего 6 байт, что в итоге = 16 + 6 = 22 байта. У объектов упаковка включает header объекта, иначе бы 6 байт упаковалось в 8.



//-------------------------------------------------------------------
    // OBJECTS
    //

    OBJECTREF Allocate();

    // This flavor of Allocate is more efficient, but can only be used
    // if CheckInstanceActivated(), IsClassInited() are known to be true.
    // A sufficient condition is that another instance of the exact same type already
    // exists in the same appdomain. It's currently called only from Delegate.Combine
    // via COMDelegate::InternalAllocLike.
    OBJECTREF AllocateNoChecks();


Некоторые структуры, например Int32, превращаются в примитивы (int) в нативном коде. Тоже самое касается и enum-ов, в целом всех value type-ов.


dwFlags2 >> 8 = TypeDef RID/token


NonVirtual методы лежат в виде списка поинтеров снизу-вверх от -1 оффсета MethodTableAuxData.
? Виртуальные слоты лежат в конце MethodTable, в виде поинтеров на чанки.
Либо они лежат до NonVirtual методов, в том же месте, также поинтеры на чанки. SlotIndex виртуальных методов меньше, чем индексы слотов не виртуальных методов.

Generic-и делят между собой методы (не все и не всегда), а также некоторые другие вещи. Каждый уникальный инстанс generic-ов имеет свой MethodTable, но одинаковый EEClass, поинтеры в слотах указывают на одинаковые чанки (таким образом шейрятся методы), однако только для ссылочных типов (canoncial), для значимых у каждого будет свой метод.