## Резюме

Книга про устройство [[CLR]], о том как работают многие конструкции языка [[CSharp]] под капотом.
Не подходит для новичков.
Вторую и третью главу пропускаем (про сборки и развёртывание, useless).

Мне пришлось переосмыслить эту книгу, обновить данные из актуальных исходников и анализировать поведение современного компилятора (с помощью sharplab).

Чтобы легко понять как работает C#/CLR на самом деле, мы начнём с самых простых и фундаментальных его частей, это даст понять причину использования многих вещей в компиляторе. Никто ведь вам не говорил про истинный смысл упаковки/распаковки? Или почему ссылочные/значимые типы - это сказка для упрощения понимания, а также причина многих мифов и легенд о работе C#/CLR? Или почему приведение типов - это ложь?

`[SkipLocalsInit]`

## Сырые данные

*Речь не про структуры в
C#*

Сырые данные (RawData/ValueObject) - это просто данные, байты, которые выравниваются исходя из многих факторов (CLR, платформа, атрибуты, порядок и смещения заданные разработчиком).
Кроме данных здесь ничего нет, даже метаданных, вся магия происходит во время компиляции.

Сырые данные могут находиться хоть на стэке, хоть в куче. На сырые данные можно получить ссылку, а можно копировать целиком.
Ссылаться стоит на данные больше ~двух указателей (16байт на x64) в размере, в остальном случае быстрее копировать и получать доступ напрямую.

Их преимущества: простота, лёгкость, скорость работы с ними и богатые возможности для оптимизации (со стороны JIT компилятора и программиста), отсутствие дорогостоящих аллокаций и сборки мусора.

Их недостатки: отсутствие метаданных, следовательно, отсутствие полиморфизма подтипов (sub-type, механизма наследования в C#), а также отсутствие работы с типом (схемой) из-за отсутствия тех же метаданных.
Т.е мы не можем узнать исходный тип (схему) сырых данных в runtim-е, следовательно, и поменять его не можем.
Однако во время компиляции мы знаем тип (схему), методы и манипуляции с полями вставляются во время компиляции и применяются к сырым данным.

Также сырые данные должны быть полностью инициализированы для использования. Т.е их не может не быть, они должны быть инициализированы хоть нулями, но данные должны быть представлены, т.к они занимают фиксированное место в памяти.

Многие эти моменты делают те же классы/структуры/enum-ы теми, кто они есть. Позже мы увидим как типы (схемы) создают сырые данные и взаимодействуют с ними.

Но есть одна главная особенность сырых данных - их можно упаковывать в объекты, а также распаковывать из объекта сырые данные. Об этом в следующей главе.

## Объект

*Речь не про объекты классов в C#*

Объект - обёртка из метаданных над сырыми данными в куче.
Объект состоит из:
- InstanceCache - это, так называемый, SyncBlockIndex (индекс блока синхронизации), размером с IntPtr. На самом деле это место может использоваться не только для хранения индекса блока синхронизации, но и для кэширования хэш-кода, пометок GC, финализации, также там содержаться флаги для определения того что там конкретно лежит. Можно даже самому использовать это место в unsafe коде для своих нужд.
-  SchemePtr - это ссылка (IntrPtr указатель) на тип (схему) или, так называемая, структура - MethodTable, которая содержит метаданные, статические поля и методы. В целом это тоже объект.
- Value - это сырые данные, которые рассматривались выше.

Объект обычно расположен в куче, а указатель на него в стэке или той же куче.
Сам по себе указатель на объект - это сырые данные, как и указатель на сырые данные.

Указатель в стэке на объект указывает на адрес указателя SchemePtr (таблицы методов) в куче. Т.е получается такая схема:
Стэк:
- Указатель на SchemePtr
Куча:
- (-8 байт смещение) InstanceCache
- (0 байт смещение) SchemePtr
- (+8 байт смещение) Value
> [!Info] Смещение 8 байт только на x64 битной архитектуре, используйте `IntPtr.Size`, чтобы не зависеть от архитектуры

Используя этот указатель и смещения, мы можем получить доступ к InstanceCache и Value.

В итоге объект - это упакованные сырые данные (Value).
Также объекты можно распаковывать (unbox) в сырые данные, копированием сырых данных объекта в стэк. Как и сырые данные, которое могут быть упакованы (box) в объект, путём создания объекта в куче и копированием туда сырых данных.
Для упаковки нам нужно знать под какой тип (схему) оборачивать объект.

Приведение типов не существует, схемы не меняются после создания объекта, просто во время компиляции вставляется сигнатура `<Тип>::<Метод>` для вызова метода. А вот уже во время вызова метода (в runtime) используется таблица методов объекта, чтобы найти переопределённый метод (если есть), благодаря чему достигается полиморфизм подтипов.

Объекты стоит использовать, когда размер сырых данных превышает размер двух указателей по 4 байт (для x32) и 8 байт (для x64) соответственно.
Стоит использовать при малом количестве инстансов, большой времени жизни объектов или при построении сложного графа объектов.

#### Создание объекта

Обычно все инстансы объектов создаются через оператор new, и вот что происходит:
1. Вычисление кол-ва байт для хранения полей + у объектов в куче дополнительно добавляются байты для указателя на объект-тип (схему, type object pointer) и для индекса блока синхронизации (sync block index / InstanceCache).
2. Выделение памяти для объекта с резервированием необходимого кол-ва байт в управляемой куче. Выделенные байты инициализируются нулями.
3. Инициализация указателя на объект-тип (схему) и индекса блока синхронизации.
4. Вызов конструктора (newobj instance) у экземпляра типа с параметрами, указанными при вызове new:
    1. Компилятор обычно (но не для ValueType/структур) вставляет в начале каждого конструктора вызов конструктора базового типа, включая пустой конструктор у Object.
    2. Затем компилятор вставляет инициализацию полей, а потом уже идёт код в конструкторе.
       Используемые в конструкторе поля инициализируются значением по умолчанию.
5. new возвращает ссылку (указатель) на созданный объект.

## Поля

Что такое поля? Вы можете предположить, что это сырые данные, но нет. Это метаданные для сырых данных. Минимальный джентльменский набор: схема(тип поля) и название. Этого достаточно, чтобы объяснить зачем они нужны и как используются на сырых данных.

Можно сказать, что поле - это сигнатура для вычленения данных из массива сырых данных.
Благодаря типу (схеме) и названию поля, т.е благодаря сигнатуре поля мы можем получить размер требуемых данных, а также тип (схему) данных.

Когда мы обращаемся к полю, используется инструкция вида - `ldflda int32 MyStruct::MyField`, которая принимает в качестве аргумента сырые данные (лежит наверху стэка) и с помощью сигнатуры возвращает адрес на ту часть, которую мы хотим получить, либо есть вариант `ldfld`(без a), что возвращает копию данных поля, а не адрес.
В качестве размера данных выступает аргумент `int32`, а в качестве смещения аргумент `MyStruct::MyField`.
Указание сигнатуры происходит во время компиляции!

Когда мы задаём значение полю, используется инструкция вида - `stfld int32 MyStruct:MyField`, которая принимает в качестве аргументов адрес на сырые данные и данные, которые мы хотим записать. В остальном всё то же самое, по сигнатуре определяется размер и смещение, а сама сигнатура, как и инструкция вставляется во время компиляции.

Помимо этого, есть ещё аналогичные инструкции для `static` полей - `ldsfld` и `stsfld`.
Единственное отличие - это то, что нам не нужно передавать туда сырые данные, с которыми мы будем оперировать, т.к сырые данные берутся из типа (схемы) `MyStruct`.

Сами по себе `static` поля - это пометка, что эти сырые данные должны относится к самой схеме (типу), а не к его инстансу. Т.е существовать в единичном экземпляре.

Константные поля - это тоже `static` поля, но помеченные модификатор `literal`, который говорит о том, что значение поля задаётся только один раз, во время компиляции. Это даёт возможность компилятору инлайнить (сворачивать константы) значения в места их использования во время компиляции, не тратя время на получение значения.

Все инициализации полей в наших классах/структурах переезжают в начало всех конструкторов (`ctor`). Инициализация `static` полей переезжает в `static` конструктор (`.cctor`). По факту в [[CLR]] нет инициализации полей значениями, поэтому единственный способ это сделать - переместить её в начало всех конструкторов, что компилятор и делает во время компиляции.

Модификатор `readonly` (`initonly` в IL) запрещает изменять значение после инициализации (в конструкторе).

Модификатор `required` - фича компилятора, которая заставляет инициализировать поле через Object Initializer (синтаксис `new MyClass() { Value = 123 };`) или конструктор помеченный атрибутом `[System.Diagnostics.CodeAnalysis.SetsRequiredMembers]`. Для своей работы добавляет атрибут `[RequiredMemberAttribute]` на схему и поле, а к пустому конструктору по умолчанию добавляет атрибут `[Obsolete]` и `[CompilerFeatureRequired]`.

Модификатор `ref`, доступный только в `ref struct`, - позволяет хранить ссылку на сырые данные, вместо значения. Доступны только в `ref struct` не просто так, а потому что использовать такие ссылки безопасно можно только на стэке, `ref struct` гарантирует нахождение сырых данных на стэке. Такие особенности связаны с сборщиком мусора и автоматическим управлением памятью в CLR. С помощью unsafe кода мы можем использовать указатели, но тогда нам придётся самим следить за памятью, чтобы ссылки куда-то указывали и чтобы выделенная память очищалась.

В итоге мы выяснили, что работа с полями похожа на работу с методами, но в облегчённом виде. Мы просто передаём сырые данные (Value) и получаем их кусочек, либо ссылку на их кусочек.

## Методы

Указатели на регион памяти с нативными инструкциями используются во время вызова метода, для упрощения, скажем что эти указатели хранятся в схеме (в таблице методов).

Изначально никаких нативных инструкций нет, есть лишь IL код в виде метаданных метода, но во время первого вызова JIT компилятор компилирует IL код в нативный, кэшируя указатель на область памяти со сгенерированным кодом (заменяя нативный переход на другой адрес).

Есть два основных способа вызова метода:
- `call instance <Схема>::<Метод>` - ищет в схеме, указанной при вызове, метод и передаёт туда сырые данные из стэка.
  Именно так, во время компиляции, вставляется вызов метода у сырых данных, т.к они не содержат метаданных, именно поэтому полиморфизм подтипов не применим к сырым данным.
- `callvirt instance <Схема>::<Метод>` - ищет сначала переопределённые методы нужной сигнатуры в схеме, а потом уже не переопределённые, как в обычном call.
  Именно этот вызов обычно применяется для всех объектов, т.к только они поддерживают переопределение методов благодаря указателю на схему (+в самой схеме указатель на родительскую схему), что позволяет определить какие методы мы можем вызывать и использовать методы родительских (в отношении нашей схемы) схем.
  Туда передаются тоже сырые данные, но уже в виде ссылки (указателя) на наш объект.
- Ещё есть `call` и `callvirt` вызовы без `instance` - всё то же самое, но сырые данные берутся из самого типа (схемы), т.е в метод передаётся ссылка на схему (тип).
  Такие вызовы используются для статических (`static`) методов. Статические методы - это обычные методы, которые применяются к сырым данным, только в данном случае под видом сырых данных используется ссылка на схему (тип).

Методы можно писать не только во время компиляции, но и в рантайме.
Используя unsafe код можно сильно не прибегать к рефлексии, если производительность важнее безопасности типов.

Методы поддерживают ad hoc полиморфизм - перегрузку методов (одинаковые имена, но разные параметры). Вариант метода выбирается во время компиляции.

Методы могут принимать и возвращать любые сырые данные.

По умолчанию короткие (<=32byte size) методы инлайнятся (код метода вставляется в место вызова) во время компиляции.
Длинные методы не инлайнятся по умолчанию, т.к это может сильно увеличить количество инструкций, особенно если вызовов много, что в итоге приводит к снижению эффективности кэша процессора, в таких случаях будет быстрее вызвать метод.
На самом деле условий инлайнинга больше, JIT принимает решение на основании многих параметров (например, сложность типов данных передаваемых в метод, или сложность конструкций в методе). Есть атрибуты `[MethodImpl(MethodImplOptions.AggressiveInlining)]` и `[MethodImpl(MethodImplOptions.NoInlining)]`, которые используются для ручного указания, но в большинстве случаев лучше оставлять поведение по умолчанию, компилятор достаточно умён, чтобы понять, когда стоит инлайнить, а когда нет.

#### Generic методы

Существуют ещё generic методы или же templatе методы, которые предоставляют нам механизм статического полиморфизма.
Мы можем написать метод, который работает с разными типами, как если бы он работал с одним.

Это мета-программирование, которое поддерживает CLR в runtim-е, даже в том же IL коде будет один template метод, т.е его компиляция под конкретный тип уже происходит в runtim-е, во время его первого использования с определённым типом (схемой).

Ещё одна интересная особенность - новый метод генерируется JIT-ом только для новых форм сырых данных, а для старых используются уже созданные, кэшированные. Т.е для `int` и `long` будут сгенерированы разные методы, а для `string`, `object`, `MyClass` нет - они имеют одинаковую форму сырых данных - ссылку размером IntPtr и принцип работы с ними будет одинаковый для них всех. Поэтому для любых ссылок сгенерируется один метод в котором используется тип `System.__Canon`, а для других сырых данных сгенерируется отдельно по методу.

Ещё одна особенность - это вызов метода у сырых данных без упаковки, если generic метод, в котором мы находимся ограничен (constraint - `where T : MyClass, IMyInterface`), таким образом мы точно знаем, во время компиляции, что передаваемые сырые данные поддерживают определённые методы, поэтому можем вызывать их без упаковки в объект. 

Из этого следует всегда задумываться стоит ли делать аргументы в виде интерфейса, что приведёт к упаковке, когда будем передавать сырые данные, а не ссылку на объект:
```cs
void Method(IMyInterface myInterface) {}
```
Либо же использовать generic-и, которые позволяют писать код без упаковок:
```cs
void Method<T>(T @object) where T : IMyInterface {}
```
Для ссылок будет использоваться один метод (подобный первому выше), а для сырых данных свой для каждого типа (схемы).
В следующий раз задумайтесь над этим, когда будете писать метод, который принимает интерфейс в качестве аргумента.

#### Extension методы

Методы расширения - это по большей части сахар компилятора, методы расширения позволяет вызывать сторонние методы так, как будто мы вызываем методы объекта.

Метод расширения - это просто статический метод в каком-то классе. Благодаря первому аргументу с модификатором `this` компилятор понимает что это метод расширения и добавляет ему атрибут `[Extension]`, что позволяет IDE добавлять подсказки в IntelliSense для вызова метода.

После компиляции наш вызов `obj.ExtensionMethod()` превращается в `ExtensionClass.ExtensionMethod(obj)`.

#### Конструкторы

Интересно, что конструкторы являются обычными методами, которые предоставляют логику инициализации сырых данных после их создания. Однако конструкторы не обязательны.
Обычные `instance` конструкторы имеют техническое название `.ctor`, `static` конструкторы имеют название `.cctor`.
Все они имеют специальные модификаторы методов - `specialname` `rtspecialname`, чтобы компилятор и [[CLR]] определяли что это конструктор.

#### Operator методы

// TODO

#### Аргументы методов

В методы мы всегда по умолчанию копируем сырые данные из стэка, будь это ссылка или сырые данные (ссылка - это тоже сырые данные). Передавая объект, передаётся копия ссылки на него, что тоже является сырыми данными.

Мы можем задать модификатор `ref` для аргумента, что позволит нам получить не копию сырых данных, а ссылку на эти сырые данные. Всё также работает и для объектов! Для них мы получаем ссылку на ссылку 🥴

Что же происходит, когда мы используем модификатор `in`?
Всё то же самое! Даже `in` заменяется на `ref`, но компилятор добавляет пару атрибутов. Для нас важен атрибут `[In]`, который запрещает установку значений по этой ссылке, только чтение. Однако, если мы передаём ссылку на ссылку, то мы можем прочитать ссылку и получить ссылку на объект, по которой можем его модифицировать. Менять нельзя только верхнюю ссылку, которую мы непосредственно передаём в аргументы!

А зачем тогда нужен модификатор `readonly ref`?
Интересно, но это тот же самый модификатор `in`, но более современный аналог, предполагается сейчас использовать именно его. Он заменяет лишь один атрибут, который мы не будем рассматривать.
Но ключевая его особенность - это возможность использования в возвращаемых значениях метода. Т.е мы можем вернуть из метода не просто сырые данные, а ссылку на эти сырые данные. Например, ссылку на элемент из массива.

Как тогда работает `out`?
Это тот же `ref`, но с атрибутом `out`, который заставляет установить значение по этой ссылке хотя бы раз. Может использоваться как способ возвращения значения из метода. Теперь представим как это работает с объектом в типичной практике: передаём ссылку на пустую ссылку (null), в методе по ссылке меняем пустую ссылку (null) на новый, созданный объект.

Модификатор `params` используется как синтаксический сахар для массивов, чтобы мы могли создавать массив прямо во время вызова метода, передавая туда бесчисленное количество аргументов (именно поэтому аргумент с этим модификатором должен быть последним аргументом). [[CLR]] не знает ничего об этом модификаторе, очередной сахар компилятора, который превращается в создание массива перед вызовом метода и его передачу.
Однако есть интересная фича, если мы вызываем пустой метод (без элементов в массиве), то он передаст `Array.Empty<T>()` (кэшированную версию массива без элементов, в единственном экземпляре), что довольно-таки полезно!

В новых версиях C# мы можем использовать Span/ReadOnlySpan с модификатором `params`, однако пустая версия вызова будет использовать `default(Span)` (пустой спан), а версия с параметрами будет создавать структуру в техническом классе `'<PrivateImplementationDetails>'` основываясь на типе (размер и выравнивание) и создаст `static readonly` поле типа этой структуры, в метаданных которого будут значения передаваемые в параметры в виде массива. Похоже на Inline Arrays, который кстати размещает статические методы по работе с такими массивами (структурами) в этот же технический класс.

Интересные атрибуты аргументов метода, которые могут заменить вам рефлексию:
1. `[CallerMemberName] string memberName` - позволяет получить строку с именем метода, который вызвал наш метод. При компиляции просто вставляет во все вызовы методов `nameof(ИмяМетода)`, в итоге макрос `nameof` при компиляции вставляет строку с названием метода.
2. `[CallerArgumentExpression(nameof(myArgument))] string expression` - то же самое, что и атрибут выше, но возвращает строковое выражение, которое ты передаёшь во время вызова метода в аргументе `myArgument`. Т.е если ты вызовешь метод, передавая в `myArgument` значение `1 + 1`, то в `expression` вставится строка `1 + 1` (вставляется во время компиляции).
3. `[CallerFilePath] string filePath` - возвращает путь к файлу, где находится метод вызывающий наш метод. Естественно путь встраивается в виде строки во время компиляции.
4. `[CallerLineNumber] int lineNumber` - возвращает номер строки в файле, где находится вызов нашего метода. Номер строки тоже встраивается во время компиляции.

#### Модификаторы методов

`virtual` - создаёт новый слот (`newslot`) c `virtual` методом в схеме. `newslot` нужен для перекрытия/скрытия базовых виртуальных методов с той же сигнатурой.
Модификатор `virtual` позволяет переопределять (`override`) метод в производных схемах.

`override` - не создаёт новый слот, но неявно добавляет модификатор `virtual` к методу. Принцип вызова таких методов с помощью `callvirt` был описан выше.
Не путать с `.override method` в IL, который биндит метод в другую схему, это используется в методах с явной имплементацией интерфейса (т.е явная имплементация переносит метод в другую схему).

`abstract` - то же самое что и `virtual`, но метод не содержит имплементации по умолчанию, а переопределение этого метода обязательно (иначе ошибка во время компиляции).

`extern` - позволяет импортировать функции из нативных библиотек, например, с помощью атрибута `[DllImport("dllpath", charset)]`.
Но по факту он предоставляет нам возможность декларировать метод без его имплементации. Мы можем сделать метод `virtual extern`, что позволит нам получить `virtual` метод без имплементации по умолчанию. Как `abstract`, но без требования имплементировать метод. Однако если у метода не будет имплементации (пустое тело), то вызов такого метода приведёт к ошибке в runtime ⚠️

`sealed` (`final` в IL) - запечатывает метод, такой метод нельзя переопределить в наследниках. Этот модификатор применим только к `virtual` методам. Он по умолчанию применяется в имплементации интерфейса, чтобы его убрать нужно добавить к имплементации модификатор `virtual`. В остальных случаях может использоваться только с модификатором `override`, что довольно-таки логично.

`partial` - чисто фича компилятора, работающая в `partial class, struct, interface, record`, позволяющая определить сигнатуру метода без реализации и без модификаторов доступа, полагая что реализация будет определена в другом файле этого же типа, но не обязательно (можно определить имплементацию там же, где и декларация). Обычно используется совместно с генераторами кода, вторая часть типа генерируется. Например, в WinForms.
Следует отметить, что к свойствам модификатор `partial` также применим.

Интересные атрибуты методов:
1. `[IsReadOnly]` - говорит компилятору, что метод не изменяет значений, особенно полезно в структурах. Это позволяет выдавать ошибку в методе, если вы пытаетесь что-то изменить, а также даёт возможность JIT-у скомпилировать более эффективный код, не копируя лишний раз сырые данные. Интересно, что многие методы в `struct record`-ах помечены этим атрибутом.
2. `[Obsolete]` - выдаёт предупреждение в IDE, что метод устаревший. В атрибуте можно писать комментарии.
3. // TODO

## Схема

*Речь не про классы в C#*

Class/Type/Scheme/Схема - это объект, в единственном экземпляре, который представляет из себя метаданные, для упрощения скажем что и ссылки на методы (в реальности всё сложнее).

Т.к схема - объект, у неё есть InstanceCache (SyncIndex), SchemePtr (MethodTablePtr) и Value (сырые данные). Можно догадаться, что в сырых данных лежит вся "статика".

В IL коде описание схемы - это `.class`.
В C# любой класс, интерфейс, структура, enum, делегат - это описание схемы или же `.class`, или же тип.

Описание схемы содержит метаданные в виде сигнатур методов с их байткодом (IL), поля и их структуру, свойства, события, атрибуты, имплементации интерфейсов (+карта интерфейсов), путь до базовой схемы, а также вложенные (nested) схемы.

При первом обращении к схеме, создаётся объект схемы на основании описания схемы (`.class`). Сама схема (объект) будет находиться в loader heap, который живёт весь domain и не обрабатывается [[GC]].
Вспомните статические классы или поля, теперь догадываетесь как они работают?

Т.е статика - это модификатор, который разделяет методы/поля обычного объекта от схемового объекта во время компиляции.
Получается, что схема может содержать `instance` и `static` члены, соответственно при определении этих членов мы указываем `instance` это или `static`.

Схема может иметь схему, расширять её функционал (`extends`). Если говорить более предметно, у этого класса **может быть** базовый, но только один, множественное наследование не предусмотрено.
С помощью этого механизма мы получаем полиморфизм подтипов, доступ к членам базового класса, возможность переопределять поведение базового класса.

Помимо расширения (`extends`) схема может имплементировать (`implements`) неограниченное количество схем (предполагаются интерфейсы). Практически то же самое, что и расширение, но расширять и переопределять можно только методы.

#### Модификаторы схем

`sealed` - запечатывает схему, такую схему нельзя расширять (`extends`) и имплементить (`implements`). Любые классы/интерфейсы с модификатором `static`, а также любые структуры превращаются в `sealed` схемы во время компиляции.

`abstract` - делает схему абстрактной, объект такой схемы нельзя создать. Обычно служит для базовых схем или схем, которые ты имплементируешь (интерфейсы).

`interface` - указывает что схема является интерфейсом, именно такие схемы можно имплементировать. Этот модификатор нужен для внутренних механизмов [[CLR]], чтобы обеспечивать правильную работу `implements`, ну и чтобы можно было отличить обычный класс от интерфейсного. Также это даёт понять, что мы не можем расширять (`extends`) класс и содержать `instance` поля.

Layout модификаторы, которые определяют метаданные для полей (их смещения, размер), чтобы эффективно упаковывать сырые данные в памяти:
- `auto` - [[CLR]] самостоятельно определяет выравнивание данных. Этот модификатор стоит на большинстве схем по умолчанию (кроме структур из C#, которые используют `sequential` для схемы).
- `sequential` - выравнивает данные в таком порядке, в каком они определены в схеме. Обычно используется для маршлинга (мапинга памяти из/в натив), чтобы гарантировать порядок.
- `explicit` - требует явного указания смещения полей (в C# через атрибут `[FieldOffset(int)]`).
Все эти модификаторы для схемы в C# задаются через атрибут `[StructLayout(LayoutKind)]`.

#### Generic схемы

// TODO
## System.Type

`System.Type` - объект из этой схемы позволяет получить доступ к самым важным частям метаданных любой схемы, а также позволяет получить более продвинутую версию `TypeInfo`, в которой есть практически все метаданные.

Рефлексия в чистом виде, обёртка над внутренними механизмами CLR для управления из C#.

## System.Object

Это схема, которая может быть применена практически к любому объекту, с помощью приведения типов, т.к схема практически любого объекта наследуется от схемы `System.Object`. Поэтому можно сказать, что System.Object - это корневая схема для всех остальных схем.

Следует отметить, что у этой схемы нет базовой (ссылка на родительскую схему пустая).

Также эта схема является маркером, что инстансы этой схемы должны быть объектами, а не сырыми данными. В IL коде такие пользовательские схемы (типы) помечаются меткой `class`, например в аргументах метода или полях можно увидеть что-то вроде этого - `class MyClass/MyInterface/MyDelegate`.

У схемы есть методы:
- virtual Equals (true если 2 объекта одинакового значения).
- virtual GetHashCode - по умолчанию возвращает (m_dwHashCodeSeed = m_dwHashCodeSeed * (ThreadId * 4 + 5) + 1) >> (32 - 26), т.е ThreadId умноженный на рандомное число, после этого хэшкод для кэширования сохраняется в поле InstanceCache (SyncBlockIndex, который по умолчанию без блокировок равен 0), либо в хедер с флагами в зависимости от того используется ли индекс блока синхронизации или нет.
- virtual ToString (по умолчанию GetType().ToString()).
- virtual Finalize (вызывается при сборке этого объекта [[GC]]) - это наш обыденный деструктор.

- GetType - возвращает обёртку над схемой для получения метаданных в рантайме в виде System.Type, для доступа к механизмам рефлексии.
- MemberwiseClone - создание пустого объекта и копирование всех полей в него, по сути просто клонирование средствами unsafe.
- .ctor - пустой конструктор без параметров, который обычно вызывается (вызов добавляется во время компиляции) в конструкторах всех схем, у которых схема System.Object базовая, но после инициализации полей.

## System.ValueType

Представляет из себя схему, у которой базовая схема - System.Object. Основной смысл существования этой схемы - это маркировка для компилятора и переопределение методов из System.Object для корректной работы с сырыми данными.
Эта схема является базовой для struct и System.Enum, но к сожалению в C# мы не можем наследоваться от System.ValueType напрямую.

Интересно, что в IL коде пользовательские схемы (типы) помечаются меткой `valuetype`, например в аргументах метода или полях можно увидеть что-то вроде этого - `valuetype MyStruct/MyEnum`.

Методы из System.Object предполагают что вы используете объекты и сравниваете их по ссылке, а не по значению, предполагается что и хэшкод тоже не зависит от значения.

Но чтобы удобно работать с сырыми данными, сравнивать куски данных по значению или вычислять хэшкод, была придумана схема System.ValueType.

Если немного погружаться в детали имплементации, то бывают простые и сложные сырые данные, по большей части именно с точки зрения сравнения по значению. Это определяется для выбора оптимальной (по производительности) стратегии вычисления хэшкода или сравнения.

Простые сырые данные - это просто куски данных без какой-либо логики, данные условия применимы к struct и enum:
- Нет ссылочных полей (т.к ссылочные поля требуют отдельного сравнения и получения хэшкода через виртуальный метод, нельзя сравнивать по ссылке или получать хэшкод ссылки)
- Без полей с плавающим числом (float, double, т.к казалось бы одинаковые числа могут быть разными + они имеют свою имплементацию Equals и GetHashCode).
- Без пробелов между полями, т.е у простых сырых данных должно быть плотное нормальное выравнивание.
- Equals и GetHashCode не переопределены.

ValueType в свою очередь всего лишь переопределяет методы:
- Equals - быстрый memcmp (сравнение по сегменту памяти), если структура простая, иначе использует рефлексию для сравнения каждого поля по-отдельности.
- GetHashCode состоит из добавленных байтов в HashCode:
    1. Указателя на индекс класса (указатель на таблицу с методами - SchemePtr).
    2. Как и в случае с Equals проверяется является ли структура простой, если да, то просто добавляем все её байты в виде сырых данных в HashCode.AddBytes.
       ==⚠️ Иначе мы просто добавляем байты первого поля, а остальные игнорятся!!!==
- ToString (GetType().ToString()) - переопределено, чтобы компилятор не боксил сырые данные в объект, используя версию из System.Object (помним что компилятор использует Object и ValueType как маркер).

Может показаться, что стоит делать простые структуры для повышения производительности, ничего не переопределяя. Но это не так. Сами по себе проверки флагов, условия и валидация могут занимать много времени, даже если код будет идти по быстрому пути.
==Поэтому лучше всего переопределять Equals и GetHashCode==, если это требуется, что в несколько сотен раз быстрее по перфомансу (в наносекундах естественно).

## Class

Класс в C# - это инструмент написания схем (`.class`) в [[CLR]], но не простых схем, а схем, у которых базовая схема это System.Object. Грубо говоря, у компилятора есть шаблон, по которому он генерирует схемы в IL, основываясь на параметрах, которые ты задаёшь.

Однако пометка `class` не просто генерирует код по шаблону, но ещё и представляет из себя маркер для компилятора, что позволяет ему определиться как работать с этими инстансами (как с сырыми данными или как с объектами) и как их создавать. В данном случае эта пометка означает, что инстансы этой схемы будут использоваться как объекты, а не как сырые данные. Т.е инстанс класса - это объект, на который мы потом будем ссылаться.

Пустой шаблон класса выглядит примерно так:
```cs
// Empty C# class
class MyClass;
// Converted to IL
.class private auto ansi beforefieldinit MyClass
    extends [System.Runtime]System.Object
{
    .method public hidebysig specialname rtspecialname 
        instance void .ctor () cil managed 
    {
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: call instance void [System.Runtime]System.Object::.ctor()
        IL_0006: ret
    }
}
```

Особенности шаблона класса в C#:
- Инстансы этого шаблона маркируется для компилятора как объект, а сам шаблон порождает объекты.
- По умолчанию всегда расширяем (`extends`, наследуемся) от System.Object.
- Всегда имеем конструктор, но при желании можно явно задать приватный конструктор без параметров.
- Во всех конструкторах после инициализации полей идёт вызов конструктора из базовой схемы.
- По умолчанию выравнивание сырых данных стоит в режиме `auto`.
- Классы с модификатором `static` превращаются в `abstract sealed` классы, а все ограничения связанные с `static` классами накладывает по большей части именно компилятор.
- Может иметь модификаторы: `static, abstract, sealed, partial, readonly`.
- Не может иметь виртуальных статических методов.
- Может иметь деструктор (можно переопределять метод Finalize).

Модификатор `readonly`, добавляет атрибут `[IsReadOnly]` и заставляет добавить модификатор `readonly` (`initonly`) всем полям, которые должны быть проинициализированы в конструкторе, без дальнейшей возможности изменения. Это можно рассматривать как поддержка иммутабельности у объектов.

Модификатор `partial` - чисто фича компилятора, позволяющая разделять один `class, struct, interface, record` на разные части в разных файлах, но по итогу всё склеится в один. Работает он также на всех вышеприведённых шаблонах, и работает только на них. Ещё это позволяет использовать модификатор `partial` для методов и свойств, разделяя декларацию и имплементацию, обычно для кодогенарторских утех.

## Interface

> [!Info] Интерфейсы определяют контракт, который класс должен реализовать.

Самое интересное, что интерфейсы в C# превращаются в абстрактные классы, помеченные модификатором `interface`. В данном случае это не только пометка для компилятора, но и для [[CLR]]. О модификаторе `interface` я писал выше в главе Схема.

Шаблоны интерфейса разворачиваются примерно в такой код:
```cs
// C#
interface MyEmptyInterface;
interface MyInterface { int MyContractMethod(); }

class MyEmptyClass : MyEmptyInterface;
class MyImplicitlyClass : MyInterface { public int MyContractMethod() => 0; }
class MyExplicitlyClass : MyInterface { int MyInterface.MyContractMethod() => 1; }
class MyDoubleClass : MyInterface
{
	public int MyContractMethod() => 0;
	int MyInterface.MyContractMethod() => 1;
}
// Converted to IL
.class interface private auto ansi abstract beforefieldinit MyEmptyInterface { }
.class interface private auto ansi abstract beforefieldinit MyInterface
{
    .method public hidebysig newslot abstract virtual 
        instance int32 MyContractMethod () cil managed { }
}
.class private auto ansi beforefieldinit MyEmptyClass
    extends [System.Runtime]System.Object
    implements MyEmptyInterface
{
    .method public hidebysig specialname rtspecialname 
        instance void .ctor () cil managed 
    {
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: call instance void [System.Runtime]System.Object::.ctor()
        IL_0006: ret
    }
}
.class private auto ansi beforefieldinit MyImplicitlyClass
    extends [System.Runtime]System.Object
    implements MyInterface
{
    .method public final hidebysig newslot virtual 
        instance int32 MyContractMethod () cil managed 
    {
        .maxstack 8
        IL_0000: ldc.i4.0
        IL_0001: ret
    }
    .method public hidebysig specialname rtspecialname 
        instance void .ctor () cil managed 
    {
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: call instance void [System.Runtime]System.Object::.ctor()
        IL_0006: ret
    }
}
.class private auto ansi beforefieldinit MyExplicitlyClass
    extends [System.Runtime]System.Object
    implements MyInterface
{
    .method private final hidebysig newslot virtual 
        instance int32 MyInterface.MyContractMethod () cil managed 
    {
        .override method instance int32 MyInterface::MyContractMethod()
        .maxstack 8
        IL_0000: ldc.i4.1
        IL_0001: ret
    }
}
.class private auto ansi beforefieldinit MyDoubleClass
    extends [System.Runtime]System.Object
    implements MyInterface
{
    .method public hidebysig 
        instance int32 MyContractMethod () cil managed 
    {
        .maxstack 8
        IL_0000: ldc.i4.0
        IL_0001: ret
    }
    .method private final hidebysig newslot virtual 
        instance int32 MyInterface.MyContractMethod () cil managed 
    {
        .override method instance int32 MyInterface::MyContractMethod()
        .maxstack 8
        IL_0000: ldc.i4.1
        IL_0001: ret
    }
}
```

Особенности шаблона интерфейса в C#:
- Инстансы этого шаблона маркируется для компилятора как объект, а сам шаблон не может порождать объекты (модификатор `abstract`).
- Расширение (`extends`, наследование) запрещено, разрешена только имплементация (`implements`).
- `instance` поля и конструкторы запрещены (`static` поля и конструктор разрешён).
- По умолчанию выравнивание сырых данных стоит в режиме `auto`, но в данном случае это не имеет значения из-за отсутствия инстансов и `instance` полей.
- Может иметь модификаторы: `partial`.
- Может содержать только `virtual` методы/свойства/события (это относится только к `instance` методам).
- Может иметь статические виртуальные/абстрактные методы/свойства, но с ограничениями во время использования (компилятор заставит вас использовать generic-и и ограничения в виде этого интерфейса, т.к иначе он не поймёт какой вызов вставить во время компиляции).

По факту все методы в интерфейсе по умолчанию `abstract` (это раскрывается в `newslot virtual abstract`), что заставляет нас их имплементировать, однако мы можем имплементировать метод в интерфейсе (имплементация по умолчанию), тогда модификатор `abstract` уйдёт.

Из кода выше мы можем увидеть особенности неявной и явной имплементации интерфейса. Но у всех у них есть модификаторы `virtual` и `newslot`, что является требованием интерфейса, т.к он может содержать только виртуальные `instance` методы.

Однако можем заметить что в классе `MyDoubleClass` неявная реализация не имеет модификаторов `virtual` и `newslot`. Это происходит потому что этот метод не используется в интерфейсе и всегда вызывается напрямую.

Явно имплементированный метод интерфейса всегда будет иметь модификаторы `private sealed(final) newslot virtual` и пометку `override` в самом теле метода (реализации). Первое нужно для поддержания совместимости с интерфейсом, а модификатор `private` не даёт вызвать метод, который кстати и так сложно вызвать из-за его названия `MyInterface.MyContractMethod` (да, это название, компилятор будет ругаться на точку и уровень доступ, вызвать такой метод можно только через рефлексию).

А с модификатором `override` не всё так просто. Грубо говоря мы помечаем этот метод специально для вызова из определённого интерфейса и его метода, т.е название метода по сути роли не играет, а то откуда мы вызываем имлементацию определяется в `override`, у нас это: `.override method instance int32 MyInterface::MyContractMethod()`.

// TODO: вызовы интерфейсных методов и неявная имплементация.


Имплементация (`implements`) интерфейса от интерфейса происходит немного иначе, чем в классах/структурах, т.к нам не нужно имплементировать его, мы просто расширяем наш контракт.
Грубо говоря, если у нас есть интерфейс `IFoo : IOne, ITwo`, то он просто будет содержать ссылки на 2 схемы `IOne, ITwo`, в своей интерфейсной карте (грубо говоря массив). И когда мы имплементим `IFoo` в каком-нибудь классе, то вся интерфейсная карта `IFoo` + сам `IFoo` добавляется в интерфейсную карту схемы класса, в итоге класс должен имплементить все эти методы, вызов `callvirt` будет учитывать это при диспетчеризации.

## Struct

Структуры - это те же классы, используют шаблон, похожий на шаблон классов.
Структуры предполагается использовать как шаблон для сырых данных, а не объектов, по факту структуры являются пометкой для компилятора, как и в случае с классами.

Инстансы структур - сырые данные, которые можно упаковывать (box) в объекты и распаковывать (unbox) обратно. Раньше я уже писал, что мы используем сырые данные в методах точно также как и объекты, тоже касается и полей. Во время компиляции вставляется нужный вызов, просто напоминаю об этом ещё раз, т.к в данной главе рассматривается во что превращается структура и какие ограничения накладывает компилятор, а то как работают объекты и сырые данные мы уже прекрасно знаем.

Пустой и типичный шаблон структуры выглядит примерно так:
```cs
// Empty C# struct
struct MyStruct;
struct MyStruct2 { public int MyField; }
// Converted to IL
.class private sequential ansi sealed beforefieldinit MyStruct
    extends [System.Runtime]System.ValueType
{
	// Only for empty struct:
	// 0 - auto, 1 - size in bytes (zero)
    .pack 0
    .size 1
}
.class private sequential ansi sealed beforefieldinit MyStruct2
    extends [System.Runtime]System.ValueType
{
    .field public int32 MyField;
}
```

Особенности шаблона структуры в C#:
- Инстансы этого шаблона маркируется для компилятора как сырые данные, а сам шаблон порождает сырые данные.
- По умолчанию всегда расширяем (`extends`, наследуемся) от System.ValueType.
- Схема с модификатором `sealed` (наследоваться от неё запрещено).
- Нет конструктора по умолчанию, в этом случае все поля инициализируются своими значениями по умолчанию (обычно 0).
- Для инициализации полей (через сахар в виде инициализации в полях) должен быть явно определён конструктор.
- Во все конструкторы вставляется инициализация полей.
- В конструкторах не создаётся вызова конструктора базовой схемы.
- По умолчанию выравнивание сырых данных стоит в режиме `sequential`, т.к предполагается совместимость с нативным кодом при маршалинге, а также чёткое неизменяемое выравнивание.
- Может иметь модификаторы: `partial, readonly, ref`.
- Не может иметь виртуальных статических методов.
- Не может иметь деструктор.

`readonly` модификатор работает точно также, как и у классов, но для структур это более важный момент, т.к методы тоже будут `[IsReadOnly]`, что в итоге позволит JIT-у компилировать более эффективный код, копируя меньше значений.

`ref` модификатор добавляет к структуре атрибут `[IsByRefLike]` и даёт понять компилятору, что инстанс (сырые данные) данной структуры может находится только на стэке. А так даёт возможность определять `ref` поля, которые должны указывать на какие-то сырые данные на стэке. Т.е у нас структура будет хранить ссылку, а не значения.
На основе `ref struct` сделаны `ReadOnlySpan/Span`-ы которые позволяют безопасно оперировать с массивами данных на стэке.

## System.Enum

System.Enum является базовой схемой для перечислений (enum), содержит множество методов по работе с ними (по большей части форматирование).
В качестве базовой схемы System.Enum использует System.ValueType, поэтому перечисления являются сырыми данными. И мы также не можем наследоваться от System.Enum в C#, как и от System.ValueType.

Переопределяет методы из System.ValueType - ToString, Equals, CompareTo, GetHashCode.
По большей части эти методы свичатся по базовому типу заданному в перечислении, и уже на основании этого производится простое действие, что-то вроде обёртки.

Переопределённые методы из System.ValueType работают хорошо, а вот метод HasFlag, определённый в System.Enum, вызывает упаковку (`box`) в объект, да и в имплементации этого метода есть вызов GetType, как и в ToString, что тоже вызывает упаковку.
Поэтому будьте осторожны с этим, лучше определить свой Extension метод для проверки флагов побитово.

## Enum

Enum-ы (перечисления) - предоставляют удобную форму определения константных перечислений в виде keyword-ов, вместо чисел. Сами по себе Enum-ы очень похожи на структуру с одним полем и несколькими константами (статические `literal` поля), которые имеют кастомные названия и число (по умолчанию число задаётся из порядка в котором определены константы, инкрементируя предыдущее число на 1, либо используется число заданное вручную).

Enum-ы всегда имеют базовую схему (наследуются) в виде System.Enum, которая тоже является флагом, что это именно перечисление. Нужно понимать что схема System.Enum наследуется от System.ValueType, что делает перечисления сырыми данными.

Перечисление имеет одно поле, тип которого по умолчанию `int`, однако этот тип можно сменить на другой числовой используя синтаксис вида `enum MyEnum : byte { }`, использовать можно только эти типы: `byte, sbyte, short, ushort, int, uint, long, ulong`, хотя сам по себе System.Enum поддерживает ещё `float, double, nint, nuint, char, bool`.
Само поле имеет техническое название `value__` и имеет модификаторы `specialname rtspecialname`, что позволяет определить перечисление помимо `extends` от System.Enum.

Для перечислений, как и для чисел, могут выполнятся побитовые операции. Это удобно для флагов, когда мы совмещаем в одно число несколько битовых флагов. Для обозначения намерения и более красивого вывода (форматирования) перечислений в виде флагов используется атрибут `[Flags]`, его использование не обязательно, но желательно.

Шаблоны перечисления выглядят примерно так:
```cs
// Empty C# struct
enum MyEnum;
enum MyEnum2 : byte { ConstName1, ConstName2 }
enum MyEnum3 : byte { ConstName1 = 5, ConstName2 }
[Flags] enum MyEnum4 : byte { Read = 1, Write = 2, Execute = 4 }
// Converted to IL
.class private auto ansi sealed MyEnum
    extends [System.Runtime]System.Enum
{
    .field public specialname rtspecialname int32 value__
}

.class private auto ansi sealed MyEnum2
    extends [System.Runtime]System.Enum
{
    .field public specialname rtspecialname uint8 value__
    .field public static literal valuetype MyEnum2 ConstName1 = uint8(0)
    .field public static literal valuetype MyEnum2 ConstName2 = uint8(1)
}

.class private auto ansi sealed MyEnum3
    extends [System.Runtime]System.Enum
{
    .field public specialname rtspecialname uint8 value__
    .field public static literal valuetype MyEnum3 ConstName1 = uint8(5)
    .field public static literal valuetype MyEnum3 ConstName2 = uint8(6)
}
.class private auto ansi sealed MyEnum4
    extends [System.Runtime]System.Enum
{
    .custom instance void [System.Runtime]System.FlagsAttribute::.ctor() = (
        01 00 00 00
    )
    .field public specialname rtspecialname uint8 value__
    .field public static literal valuetype MyEnum4 Read = uint8(1)
    .field public static literal valuetype MyEnum4 Write = uint8(2)
    .field public static literal valuetype MyEnum4 Execute = uint8(4)
}
```

Особенности шаблона структуры в C#:
- Инстансы этого шаблона маркируется для компилятора как сырые данные, а сам шаблон порождает сырые данные.
- Всегда расширяем (`extends`, наследуемся) от System.Enum.
- Схема с модификатором `sealed` (наследоваться от неё запрещено).
- Конструктор, поля, методы запрещены, разрешены только имена с заданием числового значения.
- По умолчанию выравнивание сырых данных стоит в режиме `auto`.
- Не имеет никаких модификаторов, кроме доступа.
- Имеет одно поле `value__`, по умолчанию типа `int`.
- Можно менять базовый тип одного единственного поля.
- Можем добавлять константы в виде их имён и числовых значений.

Вот такие довольно-таки слабые возможности у перечислений.
При использовании их в коде, вставляются константы. А при использовании в виде переменной используются сырые данные, на самом деле просто число, тип которого мы можем задать.
Однако, многие механизмы можно взломать 😈, расшив наши возможности, подсунув свои схемы, правда тогда мы будем лишены удобной поддержки IDE и анализаторов.

Кстати, чем дальше идём, тем больше видим костылей и слабых мест от разработчиков платформы 😅

## Delegate

Делегаты представляют из себя обёртку над указателем к нативному методу (stub-у, который уже ведёт на скомпилированный JIT-ом метод, либо на первичную JIT компиляцию этого метода после которой заменяется адрес, что в итоге приводит к первому случаю).
Т.е делегат семантически представляет из себя метод, который мы можем вызвать. Грубо говоря это даёт нам возможность получить и использовать ссылку на метод.

Делегат всегда наследуется от System.MulticastDelegate, который в свою очередь наследуется от System.Delegate, а тот от System.Object. Поэтому делегаты - это объекты.
Следует отметить, что от System.MulticastDelegate нельзя наследоваться в своих классах, компилятор не даст.

Любой делегат разворачивается в класс, единственное отличие - разные сигнатуры методов вызова.
Вот шаблон с примером:
```cs
// C# delegate
delegate int MyDelegate();
// Converted to IL
.class private auto ansi sealed MyDelegate
    extends [System.Runtime]System.MulticastDelegate
{
    .method public hidebysig specialname rtspecialname 
        instance void .ctor (
            object 'object',
            native int 'method'
        ) runtime managed { }
    .method public hidebysig newslot virtual 
        instance int32 Invoke () runtime managed { }
    .method public hidebysig newslot virtual 
        instance class [System.Runtime]System.IAsyncResult BeginInvoke (
            class [System.Runtime]System.AsyncCallback callback,
            object 'object'
        ) runtime managed { }
    .method public hidebysig newslot virtual 
        instance int32 EndInvoke (
            class [System.Runtime]System.IAsyncResult result
        ) runtime managed { }
}
```

Особенности шаблона делегата в C#:
- Инстансы этого шаблона маркируется для компилятора как объект, а сам шаблон порождает объекты.
- Всегда расширяем (`extends`, наследуемся) от System.MulticastDelegate.
- По умолчанию выравнивание сырых данных стоит в режиме `auto`.
- Схема с модификатором `sealed` (наследоваться от неё запрещено).
- Можем задать только модификатор доступа для схемы.
- Мы можем задавать сигнатуру делегата, что в итоге изменит сигнатуру сгенерированных методов Invoke/BeginInvoke/EndInvoke, конструктор не меняется. Сама же имплементация этих методов находится в нативном коде, что нам и говорят модификаторы `runtime managed`.

Компилятор в местах использования делегатов вставляет шаблонный код с кэшированием в виде `nested` класса в классе, где мы создаём делегат. Это выглядит примерно так:

```cs
// C#
delegate int MyDelegate1();
delegate int MyDelegate2(int a);

class Program
{
    public static void Main()
    {
        MyDelegate1 m1 = MyMethod1;
        MyDelegate1 m2 = AnotherClass.MyMethod20;
        MyDelegate2 m3 = MyMethod50;
        
        m1(); m2(); m3(5);
    }
    public static int MyMethod1() => 0
    public static int MyMethod50(int a) => a;
}
class AnotherClass { public static int MyMethod20() => 2; }
// Converted to IL
.class private auto ansi beforefieldinit Program
    extends [System.Runtime]System.Object
{
	// Delegate cache class
    .class nested private auto ansi abstract sealed beforefieldinit '<>O'
        extends [System.Runtime]System.Object
    {
        .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (01 00 00 00)
        .field public static class MyDelegate1 '<0>__MyMethod1'
        .field public static class MyDelegate1 '<1>__MyMethod20'
        .field public static class MyDelegate2 '<2>__MyMethod50'
    }
    .method public hidebysig static 
        void Main () cil managed 
    {
        .maxstack 2
        .locals init (
            [0] class MyDelegate1 m1,
            [1] class MyDelegate1 m2
        )

        IL_0000: ldsfld class MyDelegate1 Program/'<>O'::'<0>__MyMethod1'
        IL_0005: dup
        // Jump, if we have cached instance
        IL_0006: brtrue.s IL_001b

		// Else create new instance and save it to cache
        IL_0008: pop
        IL_0009: ldnull
        IL_000a: ldftn int32 Program::MyMethod1()
        IL_0010: newobj instance void MyDelegate1::.ctor(object, native int)
        IL_0015: dup
        IL_0016: stsfld class MyDelegate1 Program/'<>O'::'<0>__MyMethod1'

        IL_001b: stloc.0
        IL_001c: ldsfld class MyDelegate1 Program/'<>O'::'<1>__MyMethod20'
        IL_0021: dup
        IL_0022: brtrue.s IL_0037

        IL_0024: pop
        IL_0025: ldnull
        IL_0026: ldftn int32 AnotherClass::MyMethod20()
        IL_002c: newobj instance void MyDelegate1::.ctor(object, native int)
        IL_0031: dup
        IL_0032: stsfld class MyDelegate1 Program/'<>O'::'<1>__MyMethod20'

        IL_0037: stloc.1
        IL_0038: ldsfld class MyDelegate2 Program/'<>O'::'<2>__MyMethod50'
        IL_003d: dup
        IL_003e: brtrue.s IL_0053

        IL_0040: pop
        IL_0041: ldnull
        IL_0042: ldftn int32 Program::MyMethod50(int32)
        IL_0048: newobj instance void MyDelegate2::.ctor(object, native int)
        IL_004d: dup
        IL_004e: stsfld class MyDelegate2 Program/'<>O'::'<2>__MyMethod50'

        IL_0053: ldloc.0
        IL_0054: callvirt instance int32 MyDelegate1::Invoke()
        IL_0059: pop
        IL_005a: ldloc.1
        IL_005b: callvirt instance int32 MyDelegate1::Invoke()
        IL_0060: pop
        IL_0061: ldc.i4.5
        IL_0062: callvirt instance int32 MyDelegate2::Invoke(int32)
        IL_0067: pop
        IL_0068: ret
    }
    .method public hidebysig static 
        int32 MyMethod1 () cil managed 
    {
        .maxstack 8
        IL_0000: ldc.i4.0
        IL_0001: ret
    }
    .method public hidebysig static 
        int32 MyMethod50 (
            int32 a
        ) cil managed 
    {
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: ret
    }
	...
}
.class private auto ansi beforefieldinit AnotherClass
    extends [System.Runtime]System.Object
{
    .method public hidebysig static 
        int32 MyMethod20 () cil managed 
    {
        .maxstack 8
        IL_0000: ldc.i4.2
        IL_0001: ret
    }
    ...
}
```

Можно заметить, что кэш находится именно в месте создания, а не в месте нахождения целевого метода (делегат метода из AnotherClass кэшируется в Program.'<>O').
Также можем заметить, что в вызов конструктора делегата передаётся `object` и `nint`(`IntPtr`), в первое у нас передаётся `null`, т.к методы статические, а во второе передаётся указатель на метод с помощью инструкции `ldftn`, что довольно-таки интересно, т.к в C# нет простой возможности получить указатель на метод, кроме как через делегат, в итоге делаем вывод что используя Unsafe/Expression/IL мы можем вставить нужные нам инструкции и получить то, что нам не дано стандартными средствами C#, можно даже сделать свои делегаты.

Операции `+=, -=` (добавление/удаление делегата из списка вызовов в делегате) заменяется на System.Delegate.Combine и System.Delegate.Remove соответственно, которые создают новый объект, но уже с изменённым списком вызовов. В имплементации лежит довольно-таки длинный и замороченный код, учитывающий нахождение в списке: методов, нативных методов, делегатов, мультикаст делегатов.

## Record

Record-ы представляют из себя синтаксический сахар, более короткую запись для классов/структур. Самая главная их особенность - это автоматическая имлементация `IEquatable<T>` и переопределение и создание методов: `ToString, PrintMembers, operator !=/==, GetHashCode, Equals/Equals<T>, Deconstruct`, а также автоматическое определение свойств и конструктора.

Существуют 3 типа record-ов:
1. `record class` - иммутабельный класс (readonly поля). Сравнение объектов происходит по ссылке -> типу -> значениям, что довольно-таки важно, сравнение происходит по значению (сырым данным). Хэшкод = тип + значения.
2. `record struct` - read/write структура. Сравнение происходит по типу -> значениям. Хэшкод = значения.
3. `readonly record struct` - иммутабельная структура (readonly поля и `[IsReadOnly]` атрибут на структуре). Сравнение происходит по типу -> значениям. Хэшкод = значения.

По умолчанию `record` - это `record class`, поэтому модификатор `class` можно опустить, либо использовать для явности.

Наследование поддерживается только в `record class` и только от `record class`. Именно поэтому сигнатура некоторых методов отличается у `record class` и `record struct`, добавляя модификатор `virtual` и повышая доступ до `protected`, а также в структурах отсутствует свойство `EqualityContract`.

В данном случае шаблон разворачивается не в IL, а в C# код, т.к это сахар.

Пример пустого шаблона:

```cs
// Source
record MyRecordClass1;
// After compilation
[NullableContext(1), Nullable(0)]
class MyRecordClass1 : IEquatable<MyRecordClass1>
{
    [CompilerGenerated]
    protected virtual Type EqualityContract
    {
        [CompilerGenerated] get => typeof(MyRecordClass1);
    }
    [CompilerGenerated]
    public override string ToString()
    {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append("MyRecordClass1");
        stringBuilder.Append(" { ");
        if (PrintMembers(stringBuilder))
            stringBuilder.Append(' ');
        stringBuilder.Append('}');
        return stringBuilder.ToString();
    }
    [CompilerGenerated]
    protected virtual bool PrintMembers(StringBuilder builder) => false;
    [NullableContext(2), CompilerGenerated]
    public static bool operator !=(MyRecordClass1 left, MyRecordClass1 right) =>
	    !(left == right)
    [NullableContext(2), CompilerGenerated]
    public static bool operator ==(MyRecordClass1 left, MyRecordClass1 right)
    {
        if ((object)left != right)
        {
            if ((object)left != null)
                return left.Equals(right);
            return false;
        }
        return true;
    }
    [CompilerGenerated]
    public override int GetHashCode() =>
        EqualityComparer<Type>.Default.GetHashCode(EqualityContract);
    [NullableContext(2), CompilerGenerated]
    public override bool Equals(object obj) => Equals(obj as MyRecordClass1)
    [NullableContext(2), CompilerGenerated]
    public virtual bool Equals(MyRecordClass1 other)
    {
        if ((object)this != other)
        {
            if ((object)other != null)
                return EqualityContract == other.EqualityContract;
            return false;
        }
        return true;
    }
    [CompilerGenerated]
    public virtual MyRecordClass1 <Clone>$() => new MyRecordClass1(this);
    [CompilerGenerated]
    protected MyRecordClass1(MyRecordClass1 original) {}
    public MyRecordClass1() {}
}
```

Пример типичного шаблона (опустил атрибуты и то, что не поменялось):

```cs
// Source
record class MyRecordClass2(int Value);
// After compilation
class MyRecordClass2 : IEquatable<MyRecordClass2>
{
    private readonly int <Value>k__BackingField;
    public int Value
    {
        get => <Value>k__BackingField;
        init => <Value>k__BackingField = value;
    }
    public MyRecordClass2(int Value)
    {
        <Value>k__BackingField = Value;
        base..ctor();
    }
    protected virtual bool PrintMembers(StringBuilder builder)
    {
        RuntimeHelpers.EnsureSufficientExecutionStack();
        builder.Append("Value = ");
        builder.Append(Value.ToString());
        return true;
    }
    public override int GetHashCode()
    {
        return EqualityComparer<Type>.Default.GetHashCode(EqualityContract) * -1521134295 + EqualityComparer<int>.Default.GetHashCode(<Value>k__BackingField);
    }
    public virtual bool Equals(MyRecordClass2 other)
    {
        if ((object)this != other)
        {
            if ((object)other != null && EqualityContract == other.EqualityContract)
            {
                return EqualityComparer<int>.Default.Equals(<Value>k__BackingField, other.<Value>k__BackingField);
            }
            return false;
        }
        return true;
    }
    protected MyRecordClass2(MyRecordClass2 original)
    {
        <Value>k__BackingField = original.<Value>k__BackingField;
    }
    public void Deconstruct(out int Value)
    {
        Value = this.Value;
    }
}
```

Вот что поменяется, если мы сделаем `readonly record struct`/`record struct`:

```cs
// Source
readonly record struct MyReadOnlyRecordStruct(int Value);
// After compilation
[IsReadOnly]
struct MyReadOnlyRecordStruct : IEquatable<MyReadOnlyRecordStruct>
{
	// EqualityContract property removed
	// virtual modifier removed, access modifier updated: protected -> private
    private bool PrintMembers(StringBuilder builder)
    {
	    // RuntimeHelpers.EnsureSufficientExecutionStack() removed
        builder.Append("Value = ");
        builder.Append(Value.ToString());
        return true;
    }

    [CompilerGenerated]
    public static bool operator ==(MyReadOnlyRecordStruct left, MyReadOnlyRecordStruct right)
    {
	    // Reference and null checks removed
        return left.Equals(right);
    }

    [CompilerGenerated]
    public override int GetHashCode()
    {
	    // EqualityContract (type) hashcode removed
        return EqualityComparer<int>.Default.GetHashCode(<Value>k__BackingField);
    }

    [CompilerGenerated]
    public override bool Equals(object obj)
    {
        if (obj is MyReadOnlyRecordStruct) // Type check added
        {
            return Equals((MyReadOnlyRecordStruct)obj); // Boxing
        }
        return false;
    }
	// virtual modifier removed
    public bool Equals(MyReadOnlyRecordStruct other)
    {
	    // Reference, type and null checks removed
        return EqualityComparer<int>.Default.Equals(<Value>k__BackingField, other.<Value>k__BackingField);
    }
    // Constructor TypeName(TypeName original) removed
}
```

Особенности шаблона record-ов в C#:
- Может иметь модификаторы: `class, struct, readonly struct, abstract class, sealed class, partial`.
- Не забываем, что в `record`-ах можно определять методы, свойства, поля, всё как у обычных классов/структур, только с своими особенностями.
- Наследование рекордов накладывает некоторые костыльные ограничения компилятора и условности. В сложных случаях лучше перейти на явную имплементацию, вместо рекордов, рекорды нужны для небольших классов, чтобы писать меньше бойлерплейта.

## System.Array

## Namespace

CLR ничего не знает про пространство имён, в нём всегда используется полное имя типа.
Компилятор в процессе заменяет короткие имена на длинные, позволяя писать меньше кода.

## Span

## Unsafe

## GC

## Threads

## Async

## Struct

Структуры с точки зрения CLR - это класс, наследуемый от System.ValueType, который в свою очередь наследуется от System.Object.

Сама по себе структура - это класс (схема), инстанс (объект) которого может быть в двух состояниях:
1. Неупакованное состояние - сырые данные/байты (без метаданных).
2. Упакованное состояние - инстанс класса (объект)

Бывают простые структуры, а бывают нет, по большей части именно с точки зрения сравнения по значению.
Простые структуры:
- Нет ссылочных полей (т.к ссылочные поля требуют отдельного сравнения и получения хэшкода через виртуальный метод, нельзя сравнивать по ссылке или получать хэшкод ссылки)
- Без полей с плавающим числом (float, double, т.к казалось бы одинаковые числа могут быть разными + они имеют свою имплементацию Equals и GetHashCode, как и ссылочные типы).
- Без пробелов между полями, т.е у простой структуры должно быть плотное нормальное выравнивание.
- Equals и GetHashCode не переопределены.

ValueType в свою очередь всего лишь переопределяет методы:
- Equals (быстрый memcmp (сравнение по сегменту памяти), если структура простая, иначе использует рефлексию для сравнения каждого поля по-отдельности).
- GetHashCode состоит из добавленных байтов в HashCode:
    1. Указателя на индекс класса (указатель на таблицу с методами).
    2. Как и в случае с Equals проверяется является ли структура простой, если да, то просто добавляем все байты в HashCode.AddBytes.
       ==⚠️ Иначе мы просто добавляем байты первого поля, а остальные игнорятся!!!==
- ToString (GetType().ToString()).

Может показаться, что стоит делать именно простые структуры для повышения производительности. Но это не так. Сами по себе проверки флагов, условия и валидация могут занимать много времени, даже если код будет идти по быстрому пути.
==Поэтому лучше всего переопределять Equals и GetHashCode==, что в несколько сотен раз быстрее по перфомансу (в наносекундах естественно).

Структуры могут находиться как на стэке, так и в куче (внутри других объектов или в упакованном виде).

Неупакованные структуры не имеют ссылки на объект-тип (схему). То есть такие структуры - это просто кусок сырых данных. Именно компилятор вставляет в IL код прямой вызов методов для этих данных. Без безопасности типов можно было бы вставлять в один метод разные структуры 🤔

С помощью new мы можем использовать конструктор для инициализации всех полей.
Для структур инициализация полей обязательна, поэтому в пустом конструкторе компилятор сгенерирует инициализацию всех полей на значения по умолчанию (default), либо сгенерирует часть неинициализированных полей, если какая-то часть инициализируются в конструкторе.

У структур без пустого конструктора или без вызова конструктора с параметрами вместо newobj instance (вызова конструктора) вызывается initobj, который инициализирует объект значениями по умолчанию без вызова конструктора.

Структуры стоит использовать для экономии памяти и ресурсов CPU (без выделения памяти в куче, без доступа по ссылке в куче, без [[GC]]).
Используем, когда нам нужно большое количество объектов одного типа, либо когда нам нужна структура-данных для алгоритма, либо когда размер структуры не больше размера двух указателей, либо когда у объектов небольшое время жизни.
