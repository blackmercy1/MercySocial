## Демо: Sales service

  
Немного отвлечёмся от сухой теории и посмотрим в код.   
  
Конференция — это не только подготовка контента, но ещё и продажи. Давайте представим, что уже был написан сервис для продажи билетов, а к нам приходит sales-менеджер и говорит: «Ребят! Когда-то кто-то написал этот сервис, давайте разберёмся, что-то мне непонятно, как скидка для постоянных клиентов считается».  
  
Пообщавшись с менеджером, мы выясняем, что в целом сценарий этого сервиса такой: по нажатию на Checkout считается окончательная цена билета с учётом скидки постоянного клиента, и заказ переходит в состояние «Ожидание оплаты».   
  
Код, который мы сейчас разберём, можно отдельно посмотреть в [репозитории](https://github.com/a-merson/DotNext2018/tree/master/DotNext.Sales).   
  
Вроде всё выглядит неплохо: есть Application и Core (видимо, про слои человек знает), Repository… Видимо, первую половину Эванса человек осилил.   
  
Открываем OrderCheckoutService. Что мы там видим? Вот [такой код](https://github.com/a-merson/DotNext2018/blob/master/DotNext.Sales/DotNext.Sales.Application/OrderCheckoutService.cs):

```
public void Checkout(long id)  
{  
    var ord = _ordersRepository.GetOrder(id);  
    var orders = _ordersRepository.GetOrders()  
        .Count(o => o.CustomerId == ord.CustomerId   
					&& o.StateId == 3  
                    && o.OrderDate >= DateTime.UtcNow.AddYears(-3));  
  
    ord.Price *= 
    (100 - (orders >= 5 ? 30m : orders >= 3 ? 20m : orders >= 1 ? 10m : 0)) / 100;  
    
    ord.StateId = 1;  
    _ordersRepository.SaveOrder(ord);  
}
```

 Смотрим на строчку 
 ```
ord.price *=
```


 Через какое-то время с помощью форматирования и ~~нецензурной лексики~~ рефакторинга мы разбираемся, что к чему, и объясняем нашему многострадальному sales-менеджеру, что логика такая: если количество заказов за последние 3 года у человека не меньше одного, то он получает 10% скидки, не меньше трёх — 20%, и не меньше пяти — 30%. Он радостный уходит — теперь понятно, как это всё работает.   
  
Книга Роберта Мартина, говорит нам о важном правиле бойскаутов: «Место стоянки после того, как мы его покинем, должно быть чище, чем было до того, как мы туда пришли». Поэтому давайте этот код отрефакторим так, чтобы он выглядел по-человечески и соответствовал тому, о чём мы говорили чуть ранее, про ubiquitous language и его использование в коде.

```
public class DiscountCalculator  
{  
    private readonly IOrdersRepository _ordersRepository;  
    public DiscountCalculator(IOrdersRepository ordersRepository)  
    {  
        _ordersRepository = ordersRepository;  
    }  
  
  
    public decimal CalculateDiscountBy(long customerId)  
    {  
        var completedOrdersCount = _ordersRepository.GetLast3YearsCompletedOrdersCountFor(customerId);  
        return DiscountBy(completedOrdersCount);  
    }  
  
    private decimal DiscountBy(int completedOrdersCount)  
    {  
        if (completedOrdersCount >= 5)  
            return 30;  
  
        if (completedOrdersCount >= 3)  
            return 20;  
  
        if (completedOrdersCount >= 1)  
            return 10;  
  
        return 0;  
    }  
}
```

Первое, что мы делаем — это выносим расчёт скидки в отдельный DiscountCalculator, в котором появляется метод CalculateDiscountBy customerId. Читается всё по-человечески, всё понятно: что, почему и как. Внутри этого метода мы видим, что у нас есть глобально два шага расчёта скидки. Первый: мы что-то получаем из репозитория заказов, тут всё по юзкейсу, можно даже не лезть внутрь, если это не та деталь, которая вас интересует сейчас. Факт, что мы получаем количество каких-то законченных заказов, после чего вторым шагом непосредственно скидку считаем по этому количеству.  
  
Если мы хотим посмотреть, как она считается, мы идём в DiscountBy, и тут практически человеческим английским языком написано всё то же, что до этого было нашим «типа брейнфаком», всё ясно и четко.   
  
Единственный вопрос, который мог бы возникнуть — в каких единицах измеряется скидка. Можно было бы в названии метода добавить слово «проценты», чтобы было понятно, но из контекста и фигурирующих чисел, наверное, большинство догадается, что это проценты, и для краткости это можно опустить. Если же мы хотим посмотреть, что там за количество заказов было, то мы пойдём в код Repository и посмотрим. Сейчас мы этого делать не будем. В наш Service мы должны добавить новую зависимость DiscountCalculator. И посмотрим, что у нас в итоге получилось во второй версии метода Checkout.

```

public void CheckoutV2(long orderId)
{    
	var order = _ordersRepository.GetOrder(orderId);
	var discount = _discountCalculator.CalculateDiscountBy(order.CustomerId);   order.ApplyDiscount(discount);
	order.State = OrderState.AwaitingPayment;    _ordersRepository.SaveOrder(order);}


```


Смотрите, метод Checkout получает orderId, дальше получает по orderId заказ, по CustomerId этого заказа считает скидку с помощью калькулятора скидки, применяет скидку к заказу, ставит статус AwaitingPayment и сохраняет заказ. У нас на слайде был сценарий на русском языке, а здесь мы практически читаем перевод этого сценария на английский и всё понятно, всё очевидно.   
  
Понимаете, в чём прелесть? Этот код можно показывать кому угодно: не только программистам, а QA, аналитикам, заказчикам. Им всем будет понятно, что происходит, потому что всё написано человеческим языком. Я использую это в нашем проекте, у нас реально QA может посмотреть некоторые куски, сверить с Wiki и понять, что там какой-то баг. Потому что в Wiki написано так, а в коде немножко по-другому, но ему понятно, что там происходит, хотя он не разработчик. И точно так же мы можем с аналитиком обсуждать код и обсуждать его предметно. Я говорю: «Смотри, вот так это работает в коде». Последняя инстанция у нас не Wiki, а код. Всё работает так, как написано в коде. Очень важно использовать ubiquitous language при написании кода.