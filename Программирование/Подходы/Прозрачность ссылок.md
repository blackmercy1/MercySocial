### Ссылочная прозрачность в программировании

Явное поведение функции вне зависимости от передаваемого значения

В программировании ссылочная прозрачность применяется, соответственно, к программам. Поскольку они обычно состоят из подпрограмм, которые сами являются программами, это применимо и к этим подпрограммам. При этом они могут быть представлены в том числе и функциями. Это означает, что функции могут быть ссылочно-прозрачными — особенно когда вызов этих функций может быть заменен их возвращаемым значением.

```
const add = (a, b) => a + b;

const mult = (a, b) => a * b;

const x = add(2, mult(3, 4));
```

В этом примере функция `mult` является ссылочно-прозрачной, потому что любой ее вызов может быть заменен соответствующим возвращаемым значением. Это можно увидеть, заменив `mult(3, 4)` на `12`:

```
const x = add(2, 12);
```

Таким же образом `add(2, 12)` можно заменить на возвращаемое значение `14`.

```
const x = 14;
```

Эти изменения не повлияют на результат работы программы, что бы она ни выполняла. Обратите внимание, что вообще мы могли бы использовать любое другое выражение, имеющее аналогичное значение — это свойство очень полезно при рефакторинге.

С другой стороны, рассмотрите следующую функцию:

```
const add = (a, b) => {
  const result = a + b;
  console.log(`Returning ${result}`);
  return result;
};
```

Замена вызова функции `add` возвращаемым значением изменит результат её работы, поскольку больше не будет печататься сообщение с помощью `console.log`. В этом случае замена просто удалит побочный эффект, но в других случаях она может изменить значение, которое возвращается функцией.

```
const getFibsNext = () => {
  let previous = -1;
  let last = 1;

  const next = () => {
    last = previous + (previous = last);
    return previous + last;
  }

  return next;
};

const printFibs = (limit) => {
  const next = getFibsNext();
  for (let i = 0; i < limit; i += 1) {
    console.log(next());
  }
};

printFibs(10);
```

Здесь функция `next` не может быть заменена чем-либо, даже если оно имело бы такое же значение. Это связано с тем, что эта функция предназначена для возврата абсолютно разных значений при каждом вызове.

Использование таких не ссылочно-прозрачных функций требует особого внимания из-за изменяемого состояния, участвующего в вычислении. Функциональный стиль избегает таких функций в пользу их ссылочно-прозрачных версий.